

**（一）进程和线程分别是什么？它们的区别。** 

​    进程是具有一定功能的程序关于某个数据集合上的一次运行活动，==进程是系统进行资源调度和分配的一个独立单位。==      

​	线程是进程的实体，是==CPU调度和分派的基本单位==，它是==比进程更小的能独立运行的基本单位。      一个进程可以有多个线程，多个线程也可以并发执行==      

**（二）线程同步的方式有哪些？**                     

互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。

信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。       

事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。       

临界区：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。                

**（三）进程的通信方式有哪些？**

(进程同步和进程通信很容易混淆，它们的区别在于：进程通信是一种手段（进程间传输信息），进程同步是一种目的（**控制多个进程按一定顺序执行**）

**主要分为：管道、FIFO（命名管道）、系统IPC（包括消息队列、信号量、共享存储）、SOCKET（套接字）             

**==管道是一种半双工的通信方式==，数据只能==单项流动==，并且==只能在具有亲缘关系的进程间流动==，进程的==亲缘关系通常是父子进程==       

**==命名管道==也是半双工的通信方式，它==允许无亲缘关系的进程间进行通信==       

**信号量是一个计数器，用来==控制多个进程对资源的访问，它通常作为一种锁机制==。       

**消息队列是消息的[链表]()，==存放在内核中并由消息队列标识符标识==。       

**==信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生==。       

**共享内存==允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。==                **（四）进程有哪几种状态？**                        

就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源        

运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数        

阻塞状态： 进程等待某种条件，在条件满足之前无法执行                   

应该注意以下内容：==只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度[算法]()从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。==        

阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。                 

**（五）说一说进程同步有哪几种机制。**          临界区、同步与互斥、信号量、管程
 **（六） 操作系统中进程调度策略有哪几种？**
           1.批处理系统            

​			1.1   先来先服务 first-come first-serverd（FCFS）   
​            1.2   短作业优先 shortest job first（SJF）   
​            1.3   最短剩余时间优先 shortest remaining time next（SRTN）   
​          2.交互式系统            

​            2.1   时间片轮转   
​            2.2   优先级调度   
​            2.3   多级反馈队列   
​          3.实时系统           实时系统要求一个请求在一个确定时间内得到响应。      分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。           

**（七）什么是==缓冲区溢出==？有什么危害？其原因是什么？**           
缓冲区溢出是指当计算机向==缓冲区填充数据时超出了缓冲区本身的容量==，==溢出的数据覆盖在合法数据上==。危害有以下两点：           
==程序崩溃，导致拒绝额服务==      
==跳转并且执行一段恶意代码== 造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。          
**（八）什么是死锁？死锁产生的条件？**     在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。   
死锁产生的四个条件（有一个条件不成立，则不会产生死锁）         
互斥条件：一个资源一次只能被一个进程使用     
请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放    
不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺     
循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系    
**（九）说一说死锁的处理基本策略和常用方法。**

1.鸵鸟策略：      *把头埋在沙子里，假装根本没发生问题。*       因为==解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能==,==当发生死锁时不会对用户造成多大影响==，==或发生死锁的概率很低，==可以采用鸵鸟策略.大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。
2.死锁检测和死锁恢复：不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。             
3.死锁    预防：    在程序运行之前预防发生死锁。               

- 3.1破坏互斥条件：    例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。        

- 3.2==破坏请求与保持条件==：    一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。    

- 3.3==破坏不剥夺条件==    

- 3.4破坏环路等待：    ==给资源统一编号，进程只能按编号顺序来请求资源==。    

  4.死锁避免：    在程序运行时避免发生死锁。     

   **（十）分页和分段有什么区别？**  

 对程序员的透明性：==分页透明，因为可以直接计算，但是分段需要程序员显式划分每个段。==        
地址空间的维度：==分页是一维地址空间，分段是二维的。==        
大小是否可以改变：==页的大小不可变，段的大小可以动态改变。==        
出现的原因：==分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。==