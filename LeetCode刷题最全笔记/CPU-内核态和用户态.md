# CPU-内核态和用户态

- CPU的两种工作状态：内核态和用户态（或者称管态和目态）

# 内核态

- 系统中==既有操作系统的程序，也由普通用户的程序==。为了安全和稳定性操作系统的程序不能随便访问,这就是内核态
- ==内核态可以使用所有的硬件资源==

# 用户态

- ==用户态指非特权状态==。在此状态下，==执行的代码被硬件限定==，不能进行某些操作，==不能直接使用系统资源，也不能改变CPU的工作状态==，并且==只能访问这个用户程序自己的存储空间==

# 用户态和内核态

## 特权级

- ==Linux使用了Ring3级别运行用户态,Ring0标识内核态==
- Ring0作为内核态，没有使用Ring1和Ring2。
- ==Ring3状态不能访问Ring0的地址 空间，包括代码和数据==。
- ==Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块==， 以及内核所维护的数据。用户运行一个程序，该程序所==创建的进程开始是运行在用户态==的，如果==要执行文件操作，网络数据发送等操作，必须通过 write，send等系统调用==，这些==系统调用会调用内核中的代码来完成操作，这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执 行这些代码完成操作，完成后，切换回Ring3，回到用户态==。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。

# 用户态和内核态的转换

![img](https://upload-images.jianshu.io/upload_images/2231755-516fbdd1b74e17ca.png?imageMogr2/auto-orient/strip|imageView2/2/w/573/format/webp)

Paste_Image.png

## 系统调用

- 这是==用户态进程主动要求切换到内核态的一种方式==，用户态进程==通过系统调用申请使 用操作系统提供的服务程序完成工作==，比如linux中==fork()实际上就是执行了一个创建新进程的系统调用==。而系统调用的机制其核心还是使用了==操作系统为用户 特别开放的一个中断来实现==，例如Linux的int 80h中断。

## 异常

- 当==CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常==，这时会==触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。==

## 外围设备的中断

- 当 ==外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。==比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

> 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中==系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。==

## 具体的切换操作

- 从 触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态 到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而 异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态 的步骤主要包括：
  - 从当前进程的描述符中提取其内核栈的ss0及esp0信息。（保存上下文）
  - 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。
- 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。（转到内核态执行）