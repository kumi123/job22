
---
title: 缓存穿透、缓存击穿、缓存雪崩
thumbnail: true
author: Kumi
icons: [fas fa-fire red, fas fa-star green]
cover: true
date: 2020-03-02 22:20:51
mathjax: true
top_meta: true
bottom_meta: true
headimg: https://cdn.jsdelivr.net/gh/kumi123/CDN2/53.jpg
tags:
  - Redis
categories:
  - Redis
music:
 server: netease   # netease, tencent, kugou, xiami, baidu
 type: song        # song, playlist, album, search, artist
 id: 16846091      # song id / playlist id / album id / search keyword


---
# 缓存穿透、缓存击穿、缓存雪崩

**目录**

- 1、缓存穿透
  - [一、概念](https://www.cnblogs.com/ysocean/p/12452023.html#_label0_0)
  - [二、解决办法](https://www.cnblogs.com/ysocean/p/12452023.html#_label0_1)
- 2、缓存击穿
  - [一、概念](https://www.cnblogs.com/ysocean/p/12452023.html#_label1_0)
  - [二、解决办法](https://www.cnblogs.com/ysocean/p/12452023.html#_label1_1)
- 3、缓存雪崩
  - [一、概念](https://www.cnblogs.com/ysocean/p/12452023.html#_label2_0)
  - [二、解决办法](https://www.cnblogs.com/ysocean/p/12452023.html#_label2_1)

 

------

　　本篇博客我们来介绍Redis使用过程中需要注意的三种问题：**缓存穿透、缓存击穿、缓存雪崩。**

[回到顶部](https://www.cnblogs.com/ysocean/p/12452023.html#_labelTop)

### 1、缓存穿透



#### 一、概念

　　缓存穿透：缓存和数据库中都没有的数据，可用户还是源源不断的发起请求，导致每次请求都会到数据库，从而压垮数据库。

　　如下图红色的流程：

　　![img](https://img2020.cnblogs.com/blog/1120165/202008/1120165-20200808214325134-1676845673.png)

 　比如客户查询一个根本不存在的东西，首先从Redis中查不到，然后会去数据库中查询，数据库中也查询不到，那么就不会将数据放入到缓存中，后面如果还有类似源源不断的请求，最后都会压到数据库来处理，从而给数据库造成巨大的压力。



#### 二、解决办法

　　**①、业务层校验**

　　用户发过来的请求，根据请求参数进行校验，对于明显错误的参数，直接拦截返回。

　　比如，请求参数为主键自增id，那么对于请求小于0的id参数，明显不符合，可以直接返回错误请求。

　　**②、不存在数据设置短过期时间**

　　对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s，可以根据实际业务设定。注意一定不要影响正常业务。

　　**③、布隆过滤器**

　　关于布隆过滤器，后面会详细介绍。布隆过滤器是一种数据结构，利用极小的内存，可以判断大量的数据“一定不存在或者可能存在”。

　　对于缓存穿透，我们可以将查询的数据条件都哈希到一个足够大的布隆过滤器中，用户发送的请求会先被布隆过滤器拦截，一定不存在的数据就直接拦截返回了，从而避免下一步对数据库的压力。

[回到顶部](https://www.cnblogs.com/ysocean/p/12452023.html#_labelTop)

### 2、缓存击穿



#### 一、概念

　　缓存击穿：Redis中一个热点key在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。

　　![img](https://img2020.cnblogs.com/blog/1120165/202008/1120165-20200808214359739-1247536410.png)

 　这里要注意的是这是某一个热点key过期失效，和后面介绍缓存雪崩是有区别的。比如淘宝双十一，对于某个特价热门的商品信息，缓存在Redis中，刚好0点，这个商品信息在Redis中过期查不到了，这时候大量的用户又同时正好访问这个商品，就会造成大量的请求同时到达数据库。



#### 二、解决办法

　　**①、设置热点数据永不过期**

　　对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。当然这种方式比较粗暴，对于某些业务场景是不适合的。

　　**②、定时更新**

　　比如这个热点数据的过期时间是1h，那么每到59minutes时，通过定时任务去更新这个热点key，并重新设置其过期时间。

　　③**、互斥锁**

　　这是解决缓存击穿比较常用的方法。

　　互斥锁简单来说就是在Redis中根据key获得的value值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该key时，发现获取锁失败，则睡眠一段时间（比如100ms）后重试。

[回到顶部](https://www.cnblogs.com/ysocean/p/12452023.html#_labelTop)

### **3、缓存雪崩**



#### 一、概念

　　缓存雪崩：Redis中缓存的数据大面积同时失效，或者Redis宕机，从而会导致大量请求直接到数据库，压垮数据库。

　　![img](https://img2020.cnblogs.com/blog/1120165/202003/1120165-20200329215008122-335003416.png)

 　对于一个业务系统，如果Redis宕机或大面积的key同时过期，会导致大量请求同时打到数据库，这是灾难性的问题。



#### 二、解决办法

　　**①、设置有效期均匀分布**

　　避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值；

　　或者统一规划有效期，使得过期时间均匀分布。

　　**②、数据预热**

　　对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。

　　**③、保证Redis服务高可用**

　　前面我们介绍过Redis的哨兵模式和集群模式，为防止Redis集群单节点故障，可以通过这两种模式实现高可用。

　　**4、熔断机制，限流降级**
	流量达到阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。



### 两种备份方式

​	RDB快照：优缺点：

​	适合备份、灾难恢复，恢复大==数据集时比AOF快==，==出现故障时丢失的数据比AOF多，数据集大时耗时长== 

​	AOF（append only file） 追加方式有每个写命令都同步，每秒同步，操作系统决定何时同步（no） 每秒同步情况下仍可以保持良好的性能，而且在故障时最多丢失一秒的数据

​	Redis可以在AOF文件体积较大时，自动在后台对AOF进行重写，重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 

缺点：

​	AOF文件体积通常大于RDB文件体积

​	AOF处理巨大写入时会降低Redis性能







## 缓存穿透

### 什么是缓存穿透

正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是缓存和数据库都查不到这个数据，每次都会去数据库查询，这种查询不存在数据的现象我们称为缓存穿透

### 穿透带来的问题

如果每次都拿一个不存在的id去查询数据库，可能会导致你的数据库压力增大

### 解决办法

1. 缓存空值
   之所以发生穿透，是因为缓存中没有存储这些数据的key，从而每次都查询数据库
   我们可以为这些key在缓存中设置对应的值为null，后面查询这个key的时候就不用查询数据库了
   当然为了健壮性，我们要对这些key设置过期时间，以防止真的有数据
2. BloomFilter
   BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中
   我们把有数据的key都放到BloomFilter中，每次查询的时候都先去BloomFilter判断，如果没有就直接返回null
   注意BloomFilter没有删除操作，对于删除的key，查询就会经过BloomFilter然后查询缓存再查询数据库，所以BloomFilter可以结合缓存空值用，对于删除的key，可以在缓存中缓存null

## 缓存击穿

### 什么是缓存击穿

在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿

### 击穿带来的问题

会造成某一时刻数据库请求量过大

### 解决办法

采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有

## 缓存雪崩

### 什么是缓存雪崩

当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了

### 解决办法

1. 采用集群，降低服务宕机的概率
2. ehcache本地缓存 + Hystrix限流&降级
   ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵
   使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑

## 解决热点数据集中失效问题

我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。
对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况

### 解决办法

1. 设置不同的失效时间
2. 采用缓存击穿的解决办法，加锁
3. 永不失效，就是采用定时任务对快要失效的缓存进行更新缓存和失效时间





