一.什么是同步？什么是异步？

二.什么是阻塞？什么是非阻塞？

三.什么是阻塞IO？什么是非阻塞IO？

四.什么是同步IO？什么是异步IO？

五.五种IO模型

六.两种高性能IO设计模式（Reactor和Proactor）

七. java中的BIO、NIO、AIO分别是什么？

- BIO
  - 同步并阻塞，服务器实现模式为==一个连接一个线程==，即==客户端有连接请求时服务器端就需要启动一个线程进行处理==，如果==这个连接不做任何事情会造成不必要的线程开销==，当然可以使用线程池机制改善
  - BIO方式适用于==连接数比较小且固定的架构，这种对服务器资源要求较高==，JDK1.4以前的唯一选择，但程序直观易懂。
- NIO
  - 同步非阻塞，服务器实现为==一个请求一个线程==，即==客户端连接的请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理==。
  - NIO适用于==连接数目多且比较短的架构==，比如聊天服务器，编程复杂，JDK1.4才开始支持
- AIO
  - 异步非阻塞，服务器实现模式为==一个有效请求一个线程==，客户端的==IO请求都是由OS（内核）先完成在通知到服务器应用去启动线程进行处理==
  - AIO方式适用于连==接数多且连接比较长的架构==，比如相册服务器，充==分调用OS（内核）来参与并发操作，编程复杂，JDK7才开始支持==

八、NIO的了解
 将多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下处理多个客户端请求。

NIO三个核心对象：==通道(Channel)、缓冲区(Buffer)和选择器(Selector)==

具体说就是==Selector会不断轮询注册在其上的Channel==，如果==某个Channel上有新的TCP连接，读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectorKey可以获取就绪Channel的集合，进行后续I/O操作==。

NIO单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。

单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。

九、Java Reactor模式 异步非阻塞IO

下图是Reactor的多线程模型

![img](https:////upload-images.jianshu.io/upload_images/10059245-d477136d0fe64b76.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

image

其特点如下：

（1）有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求

（2）网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送。

（3）一个NIO线程可以同时处理N条链路，但是一个链路只对应一个NIO线程，防止发生并发操作问题。

下图是主从Reactor的多线程模型。

![img](https:////upload-images.jianshu.io/upload_images/10059245-a7ecc8ac26e1dffd.png?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)

image

由于单独一个Acceptor线程可能会存在性能不中的问题，所以需要主从Reactor模型。

服务端用于接收客户端的不再是一个单独的NIO线程，而是一个独立的NIO线程池。



