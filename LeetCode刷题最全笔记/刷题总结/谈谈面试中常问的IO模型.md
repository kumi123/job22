# 谈谈面试中常问的I/O模型

## 一、IO介绍

## 1.1 Java中IO的分类

以下部分源自网络相关资料。

1. IO按照处理的**数据类型**可分为:
   (1)面向字节操作的I/O接口：inputStream，outputStream
   (2)面向字符操作的接口：Reader，Writer
2. IO按照**数据的传输方式**可分为：
   (1)面向磁盘操作的I/O接口：File
   (2)面向网络操作的I/O接口：Socket

## 1.2 Unix中的五种IO模型

以下分类的前提都是Linux/Unix环境下的网络IO，这点需要注意一下。
一个输入操作通常包括两个阶段:

1. 等待数据准备好
2. 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

Unix中有五种I/O模型:

1. 阻塞式I/O
2. 非阻塞式I/O
3. I/O复用
4. 信号驱动I/O
5. 异步I/O

**阻塞I/O模型:**
最常见的一种IO模型，之前介绍过，一个read操作是分两个阶段的，==第一个阶段是，等待数据准备就绪==，==第二个阶段是将数据拷贝到调用这个IO的线程中==。阻塞是发生在第一个阶段的，当数据没有准备好时，会一直阻塞用户线程，当数据就绪后再将数据拷贝到线程中，并返回结果给用户线程。

![img](https://user-gold-cdn.xitu.io/2020/6/26/172ef17fc508d691?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

其实，大部分的socket接口都是典型的阻塞型。所谓阻塞型的接口是==指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。==



通过介绍了阻塞IO，我们很容易就会发现它的问题，那就是==阻塞会使得用户线程无法进行任何运算和请求==。一般我们的处理这种问题的情况是==使用多线程，每个链接创建一个线程，或是使用线程池来管理线程，或许可以缓解部分压力，但是不能解决所有问题。==多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。

**非阻塞式I/O**
非阻塞IO模型是这样一个过程，当应用程序发起一个read操作时，并不会阻塞，而是立刻会收到一个结果。应用程序的线程发现返回结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户内存，然后返回。

这样的一个过程，其实是需==要用户线程不断的去询问系统是否准备好了数据，这样就会一直占用CPU资源==。但是这种模型是在只专门提供某种功能的系统才有。



![img](https://user-gold-cdn.xitu.io/2020/6/26/172ef222879861c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**多路I/O复用技术**
在介绍多路复用I/O时就要先简单说明一下，select函数和poll函数。

select函数
==select函数允许进程指示内核等待多个事件中的任何一个事件发生，并且只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。==

举个例子，我们可以调用select，告知内核仅在下列情况发生时才返回：
集合 {1,4,5} 中的任何描述符准备好读；
集合 {2,7} 中的任何描述符准备好写；
集合 {1,4} 中的任何描述符有异常条件待处理；
已经经历10.2秒；
也就是说，我们调用select告知内核对哪些描述符（读、写或异常条件）感兴趣以及等待多长时间。

poll函数
poll函数起源于SVR3，最初局限于流设备。SVR4取消了这种限制，允许poll工作在任何描述符上。poll函数提供的功能与select函数类似，但是poll没有最大文件描述符数量的限制。

select函数和poll函数将就绪的==文件描述符==告诉进程后，如果进程没有对其进行IO操作，那么下次调用select函数或者poll函数时会再次报告这些文件描述符， 所以他们一般不会丢失就绪的消息，这种方式称为水平触发(Level Triggered)。

简单的解了select函数和poll函数后，下面我们就继续说==多路I/O复用模型。多路IO复用模型就是调用select或poll函数==，并且此模型的阻塞过程就是发生在调用这两个函数中的，而不是发生在真正的的I/O系统调用上的，==使用select或poll的好处在于可以用单个线程或进程，处理多个网络连接的IO。==整个过程就是select或poll函数会不断的轮询所负责的socket，当某个socket有数据到达了，就通知用户线程或进程。



![img](https://user-gold-cdn.xitu.io/2020/6/26/172f119f167f7362?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

==**信号驱动IO**==
因为实际用到的比较少, 本文不做介绍
==**异步IO**==
==异步IO模型的过程是这样的，当用户线程发起read操作时，告知内核启动读取数据操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。这样在内核执行读取数据操作时，用户线程可以继续执行，当接收到内核在整个操作都完成的信号时，就可以直接去使用数据了。==





![img](https://user-gold-cdn.xitu.io/2020/6/26/172f11bf98cb22ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

在异步IO模型中，==IO操作的两个阶段都不会阻塞用户线程或进程，这两个阶段都是由内核完成的，然后发送一个信号告知用户线程或进程操作已完成==。异步IO模型与信号驱动IO模型的区别在于，信号驱动IO模型是由内核通知用户线程何时启动一个IO操作，而异步IO模型是由内核通知我们IO操作何时完成，异步IO模型中用户线程并不需要进行实际的读写操作，只需要在内核操作完成后，接到读取完成信号后，直接使用数据即可。
异步IO是需要操作系统底层支持的，Linux从内核2.6版本才开始支持异步IO。在Java 7中就已经支持异步IO了。
本文源自网络。



## 1.3详细谈谈I/O多路复用技术

==select，poll，epoll都是IO多路复用的机制==。==I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作==。但select，poll，epoll==本质上都是同步I/O==，因为他们都需要在==读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的==，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

**补充：文件描述符fd**

文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于==表述指向文件的引用的抽象化概念==。

文件描述符在==形式上是一个非负整数==。实际上，==它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表==。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。

**select**

```
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

复制代码
```

==select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。==

==select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024==，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。

**poll**

```
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
复制代码
```

不同与select使用三个位图来表示三个fdset的方式，poll使用一个 ==pollfd的指针实现==。

poll本质上和select没有区别，它将==用户传入的fd数组拷贝到内核空间，然后查询每个fd对应的设备状态==，如果==设备就绪则在设备等待队列中加入一项并继续遍历==，如果==遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。==

它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：

1、==大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。==

2、poll还有一个特点是==“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。==

**epoll**

```
//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
int epoll_create(int size)；
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
复制代码
```

epoll是在2.6内核中提出的，是之前的==select和poll的增强版本==。相对于select和poll来说，==epoll更加灵活，没有描述符限制==。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

epoll有EPOLLLT和EPOLLET两种触发模式，==LT是默认的模式，ET是“高速”模式。==LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。

LT模式是默认模式，LT模式与ET模式的区别如下：
  LT模式：==当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。==
  ET模式：==当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。==

   

## epoll的优点：

1、==没有最大并发连接的限制，能打开的FD的上限远大于1024==（1G的内存上能监听约10万个端口）；
2、==效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；==
即Epoll最大的优点就在于它==只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。==