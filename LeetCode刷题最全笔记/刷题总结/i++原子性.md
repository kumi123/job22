## **原子性**

> 原子性是指==一个操作是不可中断的，即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰==。CPU的指令一般都是原子性的，而我们编写的代码则不一定。

**--非原子性案例：**

**案例1：i++是原子操作吗？**

i++不是一个原子操作，因为i++至少包含3个步骤：

> [1] 从内存读取i的值。
> [2] 将i的值累加1。
> [3] 将[2]得到的结果赋值给静态变量i。

在多线程环境下，i++会导致数据不一致，假设有两个线程t1、t2，i的值为1，首先t1读取i的值（1），此时t2在t1做i累加1之前，也读取了i的值（1），随后t1、t2都对读取的i的值累加1（2），并将结果值赋值给静态变量i（2），在两个线程做i++之后，i的值应该是3，但是由于i++不是原子操作，导致数据的不一致。

**案例2：在32位的JVM上读取一个long类型的变量？**

> 不是一个原子操作，因为long类型变量是64位，而在32位JVM上，一次只能读取32位，因此读写一个64位的数据时，也是非原子性操作。

## **有序性**

> 在并发环境下，程序的执行可能就会出现乱序，如下案例：

**--临界区：**

```java
class OrderExample {
    int a = 0;
    boolean flag = false;

    public void writer() {
        a = 1;
        flag = true;
    }

    public void reader() {
        if (flag) {
            a++;
            System.out.println(a);

        }
    }
}
```

此时假设有两个线程分别执行OrderExample实例的writer和reader方法，并且先执行writer，那么reader方法打印a的值为2吗？

**【有可能不是2】因为程序代码的实际执行顺序有可能和编写代码的顺序是不一致的，可能的线程运行轨迹：线程执行writer方法时，先执行flag=ture，后执行a=1，在执行a=1之前，另一个线程可能执行了reader方法，并且判断了flag为true，正当执行a++时，发现a的值为0，所以a++的结果为1，最后打印了a的值为1，随后才是执行writer方法的a=1，从而导致reader方法打印的a的值不为2。**

![img](https://pic1.zhimg.com/v2-054396499f64257bfa75fb9fa73b3f78_r.jpg)

**要理解以上案例，需要先来了解指令的执行。**

只看编写的java代码，可能会误认为一条语句就是一个步骤完成的，但是实际上，一条语句可能在CPU中会经历很多个步骤才完成，在这里为了方便讲解，假设完成一条语句需要5个先后步骤：

> **--取指 IF**
> **--译码和取寄存器操作数 ID**
> **--执行或者有效地址计算 EX**
> **--存储器访问 MEM**
> **--写回 WB**

注意：每个步骤使用到的硬件可能不同，比如：EX会使用到CPU的ALU、WB会使用到寄存器等等。

假设程序中的语句是一条语句接着一条语句去执行，如第一条语句执行IF、ID、EX、MEM、WB，接着第二条语句执行IF、ID、EX、MEM、WB。

在这里假设一个步骤消耗1个CPU时间片，那么执行一条指令就消耗了5个CPU时间片，换言之执行2条指令，需要消耗10个CPU时间片。如下：

![img](https://pic2.zhimg.com/v2-c68609d2ae919b190e11626ca573e4d5_r.jpg)

一条接着一条执行指令的效率太低了，那么就萌生了一个想法：能不能充分利用硬件资源，譬如，在指令1使用指令寄存器执行IF指令时，指令2无法使用寄存器，但是当指令1使用译码器执行ID执行时，寄存器已经空闲出来了，可以用于指令2的IF指令的执行，那么指令2可以紧跟着指令1执行完IF之后，就可以开始执行了，因此指令2无需等到指令1完全执行完成之后，才开始执行，所以可能第一条指令还没执行完成，第5条指令已经开始执行了，所以指定1和指令2的执行过程可能变成如下：

![img](https://pic4.zhimg.com/v2-896c94d0213c87d23f439c5279a0d3a3_r.jpg)

此时执行两条指令只需消耗6个CPU时间片，明显提高了CPU的工作效率。

**总结：实际的计算机执行指令也是如此工作的（流水线工作），并且分割指令的步骤会更加的多，从而更加的提高CPU的工作效率。**

**--案例1：执行语句：A = B+ C**

--分析：这条语句可以分为4条指令：

> [1] 从内存读取变量B的值存储到寄存器R1。
> [2] 从内存读取变量C的值存储到寄存器R2。
> [3] 取出寄存器R1、R2的值到内存中，做ADD运算，把运算结果存储到寄存器R3。
> [4] 取出寄存器R3的值到内存中，然后赋值到变量A中。

**--指令执行过程图：**

![img](https://pic1.zhimg.com/v2-e6deba142f9c0967ff5fa690afce6f40_r.jpg)

**--案例2：执行语句：a = b + c; d = e - f**

--分析：这两条语句可以分为8条指令：

> [1] 从内存读取变量b的值存储到寄存器Rb。
> [2] 从内存读取变量c的值存储到寄存器Rc。
> [3] 取出寄存器Ra、Rb的值到内存中，做ADD运算，把运算结果存储到寄存器Ra。
> [4] 取出寄存器Ra的值到内存中，然后赋值到变量a中。
> [5] 从内存读取变量e的值存储到寄存器Re。
> [6] 从内存读取变量f的值存储到寄存器Rf。
> [7] 取出寄存器Re、Rf的值到内存中，做ADD运算，把运算结果存储到寄存器Rd。
> [8] 取出寄存器Rd的值到内存中，然后赋值到变量d中。

**--指令执行过程图：**

![img](https://pic4.zhimg.com/v2-8cbdfb6d507ea96b96d14bbf6be15fab_r.jpg)

这个案例仅仅只是前一个案例的复杂版，为了使得语句可以正常执行，插入了5个气泡。在一段指令执行过程中，希望气泡尽可能少，因为每增加一个气泡，那么程序的执行性能可能下降10%都是都可能的，因此希望指令段中的气泡尽可能的少。此时我们再看看指令【ADD Ra Rb Rc】，可见这条指令的气泡不是因为硬件资源的冲突而导致等待，而是因为其需要使用的数据，依赖了指令【LW Rc c】，使得ADD指定的EX操作无法完成，因此不得不插入一个气泡。那么萌生一种想法：能不能在指令【LW Rc c】执行之后，执行与该指令无数据依赖的指令，从而可以消除掉这个气泡。

在这个案例，这个指令是存在的：【LW Re e】。由于从内存中读取e的操作和读取c的操作没有必然的联系，因此可以将指令【LW Re e】提升到指令【LW Rc c】之后执行，从而消除气泡。

同理可得，可以通过提升指令【LW Rf f】到指令【SW a Ra】之前执行，从而消除指令【SW a Ra】中的气泡。



**--优化后的指令执行过程图：**

![img](https://pic1.zhimg.com/v2-cff0f291fb84fb9658862789e5bf2868_r.jpg)

提升指令之后，可以发现，指令段的执行更加顺畅了，同时消耗的CPU时间片也从14个减少到了12个，指令执行得更快，可想而知，指令提升之后带来的好处。指令提升也称为指令重排。

虽然指令重排可以使得指令流水线的执行更加顺畅，但是不足的是：重排后的指令，可能会比较难理解，如同上述的指令【ADD Ra Rb Rc】之前重排了【LW Re e】，指令【SW a Ra】之前重排了【LW Rf f】，因此可能会在理解上造成一些误解。但是指令重排必须保证重排后的指令语义上和原始指令一致。

**总结：当计算机为了使程序执行的更快，一般会对指令进行重排，这种现象称为指令重排，正是由于指令重排的存在，使得我们编写的代码不见得会按照编写的顺序去执行，从而使得在并发的情况下，会出现程序的执行可能会出现乱序的情况。从另一个角度来看，指令重排也是系统性能优化的一种手段。**

## **可见性**

> 可见性是指当一个线程修改了某一个共享变量的值，其他线程可能不能立即知道这个修改。

**出现可见性问题主要是由于各种各样的优化导致的：**

> [1] 编译器优化
> [2] JVM优化
> [3] 指令重排
> [4] 硬件优化（如写吸收，批操作）

**例子：**

> [1] 写吸收是指：当往内存同一个存储单元进行连续的写的时候，可以将一段时期内的所有写数据放入到一个写队列中，最后将最后的入队的数据覆盖到内存单元上，因为写操作只有最后一个是有意义的，从而优化了写操作，避免了中间无意义的写操作，从而提升系统的性能。但是带来的一个问题：如果有线程需要访问最新的数据时，会导致无法实时可见，因为最新的数据可能在写队列中。
> [2] 又比如有一个变量t存储在内存中，此时缓存中也有一份变量t的值，在多线程环境下，线程t1修改了内存中的变量t，此时线程t2读取缓存中的缓存值，就会导致t2读取到的不是最新的数据，这也导致数据可见性问题。如下图：

![img](https://pic3.zhimg.com/v2-a86484f60e8dcd789bfea49fa3b55382_r.jpg)

> [3] JVM优化案例：

```java
public class VisibilityTest extends Thread {

    private boolean stop;

    @Override
    public void run() {
        int i = 0;
        while(!stop) {
            i++;
        }
    }

    public void stopIt() {
        stop = true;
    }

    public boolean getStop() {
        return stop;
    }

    public static void main(String[] args) throws InterruptedException {
        VisibilityTest v = new VisibilityTest();
        v.start();
        Thread.sleep(1000); // 休眠main线程，为了启动线程v
        v.stopIt(); // 设置stop为false，为了停止线程v工作
        Thread.sleep(2000);
        System.out.println("finish main");
        System.out.println(v.getStop()); // 打印stop标识，判断线程v是否已经结束
    }

}
```

![img](https://pic1.zhimg.com/v2-a9544fa833ac813a0ce8e399538d68d0_r.jpg)

按照代码的逻辑，以及打印的结果来看，线程v应该是被停止了，但是从控制台的运行状态灯，可以看出线程v还未停止。此时通过汇编工具将VisibilityTest.java对应的汇编代码打印出来，可以发现，JVM对while循环进行了优化，while循环判断的标识，只进行了一次查看，随后就一直陷入无判断的死循环。关键汇编代码如下：

![img](https://pic3.zhimg.com/v2-74f67daf825216f976d8abdf98839d56_r.jpg)

由此可见，可见性确实是优化过后，产生的一个问题，而解决可见性的办法非常简单，使用volitale关键字即可，volitale关键字和synchronized关键字一样，都是java官方提供的功能便捷的实现。

**--在stop属性加上volatile关键字之后，可见性问题就解决了：**

> private volatile boolean stop;

![img](https://pic1.zhimg.com/v2-d97155348a76b5cdd1084e5a32a45a14_r.jpg)

**Happen-Before**

根据前面介绍的原子性、有序性、可见性以及java语言规范可以总结出如下Happen-Before规则：

> [1] 程序顺序原则：一个线程内保证语义的船航行，如a = 1; b = a + 1; 这两条语句就不能指令重排了。
> [2] volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性。
> [3] 锁规则：解锁（unlock）必然发生在随后的加锁（lock）前。
> [4] 传递性：A先于B，B先于C，那么A必然先于C。
> [5] 线程的start方法先于它的每一个动作。
> [6] 线程的所有操作先于线程的终结。
> [7] 线程的中断先于被中断线程的代码。
> [8] 对象的构造方法执行结束先于finalize方法。

## **线程安全的概念**

> 线程安全指的是：某个函数、函数库在多线程环境中被调用时，能够正确地处理各个线程的局部变量，使程序功能正确完成。

**--线程非安全例子：**

![img](https://pic3.zhimg.com/v2-53871b1365d0be328a3090f359f63bb2_r.jpg)