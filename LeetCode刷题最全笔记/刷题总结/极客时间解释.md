今天看了STL源码剖析中关于红黑树的原理和实现，看完复杂的节点插入、节点颜色变换后不禁想：这些功能经典的AVL树也能实现，为什么要提出红黑树？查了些资料，并且加上自己理解，感叹红黑树的巧妙。

首先==红黑树是不符合AVL树的平衡条件的==，即每个节点的左子树和右子树的高度最多差1的二叉查找树。但是提出了为节点增加颜色，==红黑是用非严格的平衡来换取增删节点时候旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。所以红黑树的插入效率更高==！！！

这里引用一下知乎上的回答：


Answer 1：
1. ==如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。==

2. ==其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。==

3. ==map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。==
作者：Acjx
链接：http://www.zhihu.com/question/20545708/answer/58717264

Answer 2  这个总结比较好：
==红黑树的 查询性能略微逊色于AVL树，因为他比avl树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的avl树最多多一次比较，但是，红黑树在插入和删除上完爆avl树， avl树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于avl树为了维持平衡的 开销要小得多==

作者：陈智超
链接：http://www.zhihu.com/question/43744788/answer/98258881

Answer 3 ：
功能、性能、空间开销的折中结果。

==AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。==

==红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。==
基本上主要的几种平衡树看来，红黑树有着良好的稳定性和完整的功能，性能表现也很不错，综合实力强，在诸如STL的场景中需要稳定表现。
作者：Coldwings
链接：http://www.zhihu.com/question/20545708/answer/44370878

所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。


下面的文章来源：http://blog.csdn.net/klarclm/article/details/7780319

1 好处 及 用途

        红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

==红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构 能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。==

 

        当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。

 


在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。

典型的用途是实现关联数组

 

 ## 极客时间解释



为什么在工程中常常使用红黑树这种平衡二叉查找树而不是其他平衡二叉查找树呢？

1. 对于Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。
2. AVL 树是一种高度平衡的二叉树，所以查找的效率非常高。但是为了维持这种高度的平衡，每次插入、删除都要做调整，比较复杂耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。
3. 红黑树是近似平衡，并不严格平衡，在维护平衡的成本上，比 AVL 树要低。它的**插入、删除、查找各种操作性能都比较稳定**。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种**性能稳定**的平衡二叉查找树。

## 内容小结

红黑树的实现特别复杂，但是我们侧重点不在于它的实现，而是**它的由来、特性、适用的场景以及它能解决的问题。**

1. 红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。
2. 因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，**但凡是用到动态插入、删除、查找数据的场景，都可以用到它。**实现比较复杂经常借用跳表实现。

## 课后思考

动态数据结构支持动态地数据插入、删除、查找操作，除了红黑树，我们前面还学习过哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？

这里首先解释一下什么是动态数据结构：动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。而且，这些操作都非常高效。如果不高效，也就算不上是有效的动态数据结构了。所以，这里的红黑树算一个，支持动态的插入、删除、查找，而且效率都很高。链表、队列、栈实际上算不上，因为操作非常有限，查询效率不高。

**答：**

1. 散列表：插入删除查找都是O(1)，是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的，查找比较频繁的。
2. 跳表：插入删除查找都是O(logn)，并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。
3. 红黑树：插入删除查找都是O(logn)，中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。