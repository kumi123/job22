# Java里有哪些锁？Synchronized如何实现同步锁？





说到Java中的锁，大伙们到底知道多少呢？这可是面试中常问的话题哦。在说Java中有哪些锁之前，首先咱们说说Java锁是什么，他解决了什么问题？

![Java里有哪些锁？Synchronized如何实现同步锁？](https://www.javazhiyin.com/wp-content/uploads/2019/11/java7-1573392076.png)

看到上图了吧，说说发生了什么事呢？来自四个方向的车都想同时争着过十字路口，结果拥堵在一起动不了了。这体现在Java开发中，就是多个线程需要同时使用一个对象（多数为增删改操作），那就会发生资源争夺或脏数据的问题。那怎么解决呢？这就需要使用锁来解决。多个线程谁获取锁，谁执行，否则等待，也就像十字路口，那个方向绿灯亮（获取了十字路口这个对象的锁）车就通行，否则等待。这样就解决了争夺资源造成脏数据或死锁的问题。

在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。

**一，Java有哪些锁？**

- 公平锁/非公平锁
- 可重入锁
- 独享锁/共享锁
- 互斥锁/读写锁
- 乐观锁/悲观锁
- 分段锁
- 偏向锁/轻量级锁/重量级锁
- 自旋锁

## **1，公平锁/非公平锁**

==公平锁指多个线程按照申请锁的顺序来获取锁==。==非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序==，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

对于Java中的ReentrantLock而言，==通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。==

对于==Synchronized而言，也是一种非公平锁。==由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

## **2，可重入锁**

可重入锁又名递归锁，是指在==同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁==。说的有点抽象，下面会有一个代码的示例。

对于ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。对于Synchronized而言，也是一个可重入锁。可重入锁的一个好处是==可一定程度避免死锁==。

```
synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}

synchronized void setB() throws Exception{
    Thread.sleep(1000);
}
```

上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。

## **3，独享锁/共享锁**

==独享锁是指该锁一次只能被一个线程所持有==。而==共享锁是指该锁可被多个线程所持有==。对于ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类==ReadWriteLock，其读锁是共享锁==，其写锁是独享锁。

读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。

## **4，互斥锁/读写锁**

上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。==互斥锁在Java中的具体实现就是ReentrantLock====读写锁在Java中的具体实现就是ReadWriteLock==

## **5，乐观锁/悲观锁**

==乐观锁认为对于同一个数据的并发操作，是不会发生修改的==。在更新数据的时候，会采用==尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是不会有问题的==。

==悲观锁则认为对于同一个数据的并发操作，一定是会发生修改的==，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，==悲观锁采取加锁的形式==。悲观的认为，不加锁的并发操作一定会出问题。

从上面的描述我们可以看出，==悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景==，不加锁会带来大量的性能提升。

悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是==CAS算法==，典型的例子就是==原子类，通过CAS自旋实现原子操作的更新==。

## **6，分段锁**

==分段锁其实是一种锁的设计，并不是具体的锁==，对于ConcurrentHashMap 1.7而言，其并发的实现就是==通过分段锁的形式来实现高效的并发操作==。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为==Segment==，它即类似于HashMap的结构，即==内部拥有一个Entry数组，数组中的每个元素又是一个链表==；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。

==当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁==，所以当==多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入==。
但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。

分段锁的设计目的是==细化锁的粒度==，==当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作==。

## **7，偏向锁/轻量级锁/重量级锁**

这三种锁是指锁的状态，并且是针对Synchronized。

偏向锁是指==一段同步代码一直被一个线程所访问==，那么该线程会==自动获取锁==。==降低获取锁的代价==。

==轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不阻塞，提高性能。==

==重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。==

## **8，自旋锁**

在Java中，==自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU==。





















**二，Synchronized如何实现同步锁？**

==Java中每一个对象都可以作为锁==，这是synchronized实现同步的基础。当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当==退出或者抛出异常时必须要释放锁==，那么它是如何来实现这个机制的呢？

Java中==同步代码块==是使用==monitorenter和monitorexit==指令实现，==同步方法==依靠的是方法修饰符上的==ACCSYNCHRONIZED==实现。

**同步代码块：**

==Monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置==，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。==任何对象都有一个monitor与之相关联==，当且一个==monitor被持有之后，他将处于锁定状态==。==线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁==；

**同步方法:**

Synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在==Class文件的方法表中将该方法的accessflags字段中的synchronized标志位置1==，==表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。==

==**Synchronized用的锁是存在Java对象头里。**==

Hotspot虚拟机（Sun公司）的==Java对象头==主要包括两部分数据：==**Mark Word（标记字段）**和 **Klass Pointer（类型指针）**==。

其中Klass Point是是==对象指向它的类元数据的指针==，==虚拟机通过这个指针来确定这个对象是哪个类的实例==，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。

Mark Word用于存储对象自身的==运行时数据==，如==哈希码（HashCode）、GC分代年龄==、==锁状态标志==、线程持有的锁、偏向线程 ID、偏向时间戳等等。

下图是Java对象头的存储结构（32位虚拟机）：

　![Java里有哪些锁？Synchronized如何实现同步锁？](https://www.javazhiyin.com/wp-content/uploads/2019/11/java5-1573392076.png)

Monitor，可认为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。所有的Java对象是天生的Monitor，==**每一个Java对象都有成为Monitor的潜质**==，因为在Java的设计中 ，==每一个Java对象自打娘胎里出来**就带了一把看不见的锁，它叫做内部锁或者Monitor锁。**==

Monitor 是==线程私有的数据结构，每一个线程都有一个可用====monitor record列表==，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。

Synchronized这是并发编程的重点和难点，这里面涉及的知识很多，如Java对象头、Monitor等，要想知道更多，那就得深入学习理解，我这里只是简单的介绍引导。