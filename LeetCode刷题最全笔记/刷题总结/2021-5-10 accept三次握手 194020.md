## 叙述

Linux网络编程开发分为==服务器端和客户端两个部分==：
对于服务器端的流程——类似于接电话过程

socket()[找到一个可以通话的手机]----->bind()[插入一个固定号码]------>listen()[随时准备接听]-------> accept------->recv()------->send()------>close();

对于客户端的主要流程----类似于打电话过程

socket()----->connect()------>recv/read/send------>close()

三个接口函数介绍
1.  connect（）函数：是一个==阻塞函数==   作用：==通过TCP三次握手建立连接==

客户端主动连接服务器，通过TCP三次握手通知Linux内核自动完成TCP 三次握手连接 如果连接成功为0 失败返回值-1

一般的情况下客户端的connect函数，==默认是阻塞行为，直到三次握手阶段成功为止。==

2.  服务器端的listen() 函数：==不是一个阻塞函数==： 功能：==将套接字和套接字对应队列的长度告诉Linux内核==。

他是==被动连接的一直监听来自不同客户端的请求==， listen函数将socketfd 变成被动的连接监听socket 其中参数backlog作用设置内核中队列的长度 。

注：listen的函数形式int listen(int sockfd, int backlog);  backlog代表listen队列的长度。

3. ==accept() 函数阻塞：从处于established 状态的队列中取出完成的连接，当队列中没有完成连接时候，会形成阻塞，直到取出队列中已完成连接的用户连接为止==（Accept默认会阻塞进程，直到有一个客户连接建立后返回）。

   

## 和三次握手的关系

对应关系
 在TCP/IP详解中，这三个函数与TCP三次握手之间的对应关系是这样的

==服务器调用listen进行监听==
==客户端调用connect来发送syn报文==
==服务器协议栈负责三次握手的交互过程。连接建立后，往listen队列中添加一个成功的连接，直到队列的最大长度。==
==服务器调用accept从listen队列中取出一条成功的tcp连接，listen队列中的连接个数就少一个==

## 总结

TCP的三次握手是有客户端调用connect()函数以及服务器端的协议栈共同完成的。



服务器端的listen函数负责监听客户端的连接请求，并维护一个listen队列，当有客户端连接成功时，就把它放在listen队列里。



==accept()函数负责查看listen队列里面有没有成功连接，如果有则从队列中取出==，没有则阻塞（直到获得一个成功连接返回）。它每取出一个成功连接，就会生成一个对应的accept fd，用于唯一标识该连接成功的客户端。





# 另外一个函数详细版本



### listen()、connect()函数

如果作为一个==服务器==，在调用socket()、bind()之后就会==调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求==。

```text
int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

listen函数的第一个参数即为==要监听的socket描述字==，第二个参数为相应socket==可以排队的最大连接个数==。socket()函数创建的socket默认是一个主动类型的，==listen函数将socket变为被动类型的，等待客户的连接请求==。

connect函数的第一个参数即为==客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度==。==客户端通过调用connect函数来建立与TCP服务器的连接==。

### accept()函数

==TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了，先监听。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求，再连接。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。==

```text
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //返回连接connect_fd
```

参数sockfd

参数sockfd就是上面解释中的监听套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用这个一个端口号，而此时这个端口号正与这个套接字关联。当然客户不知道套接字这些细节，它只知道一个地址和一个端口号。

参数addr

这是一个结果参数，它用来接受一个返回值，这返回值指定客户端的地址，当然这个地址是通过某个地址结构来描述的，用户应该知道这一个什么样的地址结构。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL。

参数len

如同大家所认为的，它也是结果的参数，用来接受上述addr的结构的大小的，它指明addr结构所占有的字节个数。同样的，它也可以被设置为NULL。

如果accept成功返回，则服务器与客户已经正确建立连接了，此时服务器通过accept返回的套接字来完成与客户的通信。

注意：

==accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。==

此时我们需要区分两种套接字，

监听套接字: 监听套接字正如accept的参数sockfd，它是监听套接字，==在调用listen函数之后，是服务器开始调用socket()函数生成的，称为监听socket描述字(监听套接字)==

连接套接字：一个套接字会从主动连接的套接字变身为一个监听套接字；而==accept函数返回的是已连接socket描述字(一个连接套接字)，它代表着一个网络已经存在的点点连接。==

一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。

自然要问的是：为什么要有两种套接字？原因很简单，如果使用一个描述字的话，那么它的功能太多，使得使用很不直观，同时在内核确实产生了一个这样的新的描述字。

连接套接字socketfd_new 并没有占用新的端口与客户端通信，依然使用的是与监听套接字socketfd一样的端口号