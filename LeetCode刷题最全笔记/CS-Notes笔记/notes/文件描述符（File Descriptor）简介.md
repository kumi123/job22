# [文件描述符（File Descriptor）简介](https://segmentfault.com/a/1190000009724931)

> [维基百科](https://zh.wikipedia.org/wiki/文件描述符):文件描述符在形式上是一个非负整数。实际上，它是一个==索引值，指向内核为每一个进程所维护的该进程打开文件的记录表==。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。

### 一、文件描述符概念

　　Linux 系统中，把一切都看做是文件，==当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符==，==文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件==，所有执行I/O操作的系统调用都会通过文件描述符。

### 二、文件描述符、文件、进程间的关系

#### 1.描述：

- ==每个文件描述符会与一个打开的文件相对应==
- ==不同的文件描述符也可能指向同一个文件==
- 相==同的文件可以被不同的进程打开，也可以在同一个进程被多次打开==

#### 2.系统为维护文件描述符，建立了三个表

- 进程级的文件描述符表
- 系统级的文件描述符表
- 文件系统的i-node表 ([转到：阮一峰——理解inode](http://www.ruanyifeng.com/blog/2011/12/inode.html))

![img](https://segmentfault.com/img/bVOX3l?w=619&h=312)

#### 3.通过这三个表，认识文件描述符

![图片描述](https://segmentfault.com/img/bVOX3m?w=617&h=392)

- 在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（#23），这可能是该进程多次对执行`打开`操作
- 进程A中的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（#73），这种情况有几种可能，1.进程A和进程B可能是父子进程关系;2.进程A和进程B打开了同一个文件，且文件描述符相同（低概率事件=_=）；3.A、B中某个进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程。
- 进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（#1936），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了打开请求。同一个进程两次打开同一个文件，也会发生类似情况。

前人的思考，我们的阶梯，这部分参考自网络：[链接](http://blog.csdn.net/cywosp/article/details/38965239)

### 三、==文件描述符限制==

　　有资源的地方就有战争，“文件描述符”也是一种资源，系统中的每个进程都需要有“文件描述符”才能进行改变世界的宏图霸业。世界需要秩序，于是就有了“==文件描述符限制==”的规定。

#### 如下表：

![图片描述](https://segmentfault.com/img/bVOX3o?w=651&h=289)

永久修改用户级限制时有三种设置类型：

1. `soft` 指的是当前系统生效的设置值
2. `hard` 指的是系统中所能设定的最大值
3. `-` 指的是同时设置了 soft 和 hard 的值

命令讲解:

- [ulimit](http://man.linuxde.net/ulimit)
- [sysctl](http://man.linuxde.net/sysctl)

### 四、==检查某个进程的文件描述符相关内容==

步骤(以nginx为例，*注意权限问题，此示例是在本地环境)：

1. 找到需要检查的进程id

![img](https://segmentfault.com/img/bVOX3F?w=801&h=130)

如图，找到的进程id为 1367

1. 查看该进程的限制

![图片描述](https://segmentfault.com/img/bVOX3r?w=709&h=309)

如图，在 Max open files 那一行，可以看到当前设置中最大文件描述符的数量为1024

1. 查看该进程占用了多少个文件描述符

![图片描述](https://segmentfault.com/img/bVOX3S?w=766&h=341)

如图所示，使用了17个文件描述符

### 总结

　　实际应用过程中，如果出现==“Too many open files” , 可以通过增大进程可用的文件描述符数量来解决==，但往往故事不会这样结束，很多时候，并不是因为进程可用的文件描述符过少，而是因为程序bug，==打开了大量的文件连接（web连接也会占用文件描述符）而没有释放。程序申请的资源在用完后及时释放，才是解决“Too many open files”的根本之道==。