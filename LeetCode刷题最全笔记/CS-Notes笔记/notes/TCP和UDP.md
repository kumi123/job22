# 百度网盘链接：

https://pan.baidu.com/s/1V3XQNrY15AninYXA16nOQg    提取码：nu3p

# 第五层 传输层

## 考纲内容

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594473411042-22af2c96-679d-4ed5-8708-14b695b6bc14.png)

## 复习提示

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594473423359-373b4505-de6c-4f49-b693-dfe803e6fc34.png)

## 5.1 传输层提供的服务

### 5.1.1 传输层的功能

从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。

传输层位于网络层之上，它为运行在不同主机上的进程之间提供了逻辑通信，而网络层提供主机之间的逻辑通信。显然，即使网络层协议不可靠( 网络层协议使分组丢失、混乱或重复)，传输层同样能为应用程序提供可靠的服务。

从图5.1可以看出，网络的边缘部分的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有传输层和应用层，而路由器在转发分组时都只用到下三层的功能(即在通信子网中没有传输层，传输层只存在于通信子网以外的主机中)。

传输层的功能如下:

1) 传输层提供应用进程之间的逻辑通信(即端到端的通信)。与网络层的区别是，网络层提供的是主机之间的逻辑通信。

从网络层来说，通信的双方是两台主机，IP 数据报的首部给出了这两台主机的IP地址。但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称端到端的逻辑通信。这里“逻辑通信”的意思是：传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有一条水平方向的物理连接。

2) 复用和分用。

复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据;

分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。

注意：传输层的复用分用功能与网络层的复用分用功能不同。网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594474080087-f47a28ac-9c7e-43c3-ae7d-4fb040927ba3.png)

3) 传输层还要对收到的报文进行差错检测(首部和数据部分)。而网络层只检查IP数据报的首部，不检验数据部分是否出错。

4) 提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。而网络层无法同时实现两种协议(即在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式)。

传输层向高层用户屏蔽了低层网络核心的细节(如网络拓扑、路由协议等)，它使应用进程看见的是好像在两个传输层实体之间有一条端到端的逻辑通信信道，这条逻辑通信信道对上层的表现却因传输层协议不同而有很大的差别。当传输层采用面向连接的TCP时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。但当传输层采用无连接的UDP时，这种逻辑通信信道仍然是一条不可靠信道。

### 5.1.2 传输层的寻址与端口

#### 1.端口的作用

端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。端口是传输层服务访问点(TSAP)，它在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用，只不过IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程。

数据链路层的SAP是MAC地址，网络层的SAP是IP地址，传输层的SAP是端口。

在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。

硬件端口是不同硬件设备进行交互的接口，

而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。

传输层使用的是软件端口。

#### 2.端口号

应用进程通过端口号进行标识，端口号长度为16bit，能够表示![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594474722072-c0d2a730-361b-41b2-835d-f6b0030d2d4c.png)个不同的端口号。端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类:

1) 服务端使用的端口号。这里又分为两类，最重要的一类是熟知端口号，数值为0~1023，IANA (互联网地址指派机构)把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。另一类称为登记端口号，数值为1024~49151。它是供没有熟知端口号的应用程序使用的，使用这类端口号必须在IANA登记，以防止重复。一些常用的熟知端口号如下:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594474915381-dc140b97-31cb-4198-984c-9db8c2493ccd.png)

2) 客户端使用的端口号，数值为49152~65535。由于这类端口号仅在客户进程运行时才动态地选择，因此又称短暂端口号(也称临时端口)。通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程使用。

#### 3.套接字

在网络中通过IP 地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程。在网络中采用发送方和接收方的套接字(Socket) 组合来识别端点。所谓套接字,  实际上是一个通信端点，即

套接字= (主机IP地址，端口号)

它唯一地标识网络中的一台主机和其上的一个应用(进程)。

在网络通信中，主机A发给主机B的报文段包含目的端口号和源端口号，源端口号是“返回地址”的一部分， 即当B需要发回一个报文段给A时，B到A的报文段中的目的端口号便是A到B的报文段中的源端口号(完全的返回地址是A的IP地址和源端口号)。

### 5.1.3 无连接服务与面向连接服务

面向连接服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接。

无连接服务是指两个实体之间的通信不需要先建立好连接，需要通信时，直接将信息发送到“网络”中，让该信息的传递在网上尽力而为地往目的地传送。

TCP/IP协议族在IP层之上使用了两个传输协议：一个是面向连接的传输控制协议(TCP)，采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道；另一个是无连接的用户数据报协议(UDP)， 采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。

TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或组播服务。由于TCP提供面向连接的可靠传输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的头部增大很多，还要占用许多的处理机资源。因此TCP主要适用于可靠性更重要的场合，如文件传输协议(FTP)、超文本传输协议(HTTP)、远程登录(TELNET)等。

UDP是一个无连接的非可靠传输层协议。它在IP之上仅提供两个附加服务：多路复用和对数据的错误检查。IP知道怎样把分组投递给一台主机，但不知道怎样把它们投递给主机上的具体应用。UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认。由于UDP比较简单，因此执行速度比较快、实时性好。使用UDP的应用主要包括小文件传送协议(TFTP)、 DNS、SNMP和实时传输协议(RTP)。

注意:

1) IP数据报和UDP数据报的区别： IP数据报在网络层要经过路由的存储转发；而UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时, UDP数据报的信息对路由是不可见的。

2) TCP和网络层虚电路的区别： TCP 报文段在传输层抽象的逻辑信道中传输，对路由器不可见；虚电路所经过的交换结点都必须保存虚电路状态信息。在网络层若采用虚电路方式，则无法提供无连接服务；而传输层采用TCP不影响网络层提供无连接服务。

### 5.1.4 本节习题（只记录错题和有料）

#### 一、单项选择题

有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476081589-c48aa525-d476-4137-8558-d1d806c923c6.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476088318-f4378212-6e3e-499d-b8a9-63042b8bca08.png)

关键：我还纠结了一下B，有点搞混了，确实尽力而为就代表不确定，那就是不可靠的，毕竟是无连接的



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476290224-77724d8b-d98d-46a2-b43f-c9c2424cd226.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476405255-d8fa1c0e-73e5-421b-ae6f-5060a7aa226f.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476414318-c8d908fc-978f-40a4-bb05-cc31ab6d5a2e.png)

关键：本人选C，IP地址不是动态的么？要是变了咋确定？为啥MAC地址不行？



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476498835-6951ddd5-86f0-4d71-bf44-0b7dd947121a.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476506435-cb54e168-009f-408e-b548-6afe75817f02.png)

关键：我刚看完所以记得，这里解析里刚好总结了一下，拿出来看看加深印象



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476573585-12ceb8db-0631-446d-af29-855140065ebe.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476579410-e01cbf5f-54a8-4fa0-94a5-df81cc893df2.png)

关键：我服了，原来这个也要记啊= -、太难了



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476660580-63e82e19-a589-4614-99d7-88b89183f745.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476677505-f1d0b026-fece-4b5e-8b6c-848c942f41e4.png)

关键：这个上面貌似没有讲到过是否能在同一台主机，但想想也是能的。



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476803894-41ffda0b-4491-472c-9d8a-ee02a812480a.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476811761-6d7c40e5-da79-410e-ae48-e7cd1a7190a4.png)

关键：我都很惊奇我自己记得是20B，但这个TCP的没看过，那和之前的都一样那就比较好记忆



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476857359-25eca4ea-7f80-4111-8c96-07ea26e7d11b.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476864877-19e091e0-86bb-442e-8c58-08831c9354ee.png)

关键：这个在这一章以及之前的章节里都有提到过，现在再拿出来看看

## 5.2 UDP 协议

### 5.2.1 UDP 数据报

#### 1. UDP概述

RFC 768定义的UDP只是做了传输协议能够做的最少工作，它仅在IP的数据报服务之上增加了两个最基本的服务：复用和分用以及差错检测。如果应用程序开发者选择UDP而非TCP，那么应用程序几乎直接与IP打交道。

为什么应用开发人员宁愿在UDP之上构建应用，也不选择TCP？既然TCP提供可靠的服务，而UDP不提供，那么TCP总是首选吗？答案是否定的，因为有很多应用更适合用UDP，主要是因为UDP具有如下优点:

1) UDP无须建立连接。因此UDP不会引入建立连接的时延。试想如果DNS运行在TCP而非UDP上，那么DNS的速度会慢很多。HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，可靠性是至关重要的。

2) 无连接状态。TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数。而UDP不维护连接状态，也不跟踪这些参数。因此，某些专用应用服务器使用UDP时，一般都能支持更多的活动客户机。

3) 分组首部开销小。TCP有20B的首部开销，而UDP仅有8B的开销。

4) 应用层能更好地控制要发送的数据和发送时间。UDP没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而UDP正好满足这些应用的需求。

UDP常用于一次性传输较少数据的网络应用，如DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。UDP也常用于多媒体应用(如IP电话、实时视频会议、流媒体等)，显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。

UDP提供尽最大努力的交付，即不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成。应用实体可以根据应用的需求来灵活设计自己的可靠性机制。

UDP是面向报文的。发送方UDP对应用层交下来的报文，在添加首部后就向下交付给IP层，既不合并，也不拆分，而是保留这些报文的边界；接收方UDP对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。因此报文不可分割，是UDP数据报处理的最小单位。

#### 2. UDP的首部格式

UDP数据报包含两部分: UDP首部和用户数据，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，如图5.2 所示。UDP首部有8B，由4个字段组成，每个字段的长度都是2B，如图5.2所示。各字段意义如下:

1) 源端口。源端口号。在需要对方回信时选用，不需要时可用全0。

2) 目的端口。目的端口号。这在终点交付报文时必须使用到。

3) 长度。UDP数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)。

4) 校验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476957128-f39579f0-3732-4851-9509-58f11edb3cc8.png)

当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程，如图5.3所示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594476982290-8d958110-85ae-47dd-bd1a-d23404c5f40d.png)

如果接收方UDP发现收到的报文中的目的端口号不正确(即不存在对应于端口号的应用进程)，那么就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。

### 5.2.2 UDP校验

在计算校验和时，要在UDP数据报之前增加12B的伪首部，伪首部并不是UDP的真正首部。只是在计算校验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。伪首部既不向下传送也不向上递交，而仅为了计算校验和。这样的校验和，既检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。图5.4给出了UDP数据报的伪首部各字段的内容。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594477025177-4066094c-8544-439d-a94f-6810f623c618.png)

UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反。但不同的是，IP数据报的校验和只检验IP数据报的首部，但UDP的校验和则检查首部和数据部分。

发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16 位的字连接起来。若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节(但此字节不发送)。接下来按二进制反码计算出这些16位字的和，并将此和的二进制反码写入校验和字段。接收方把收到的UDP数据报加上伪首部( 如果不为偶数个字节，那么还需要补上全零字节)后，按二进制反码计算出这些16位字的和。当无差错时其结果应全为1，否则表明有差错出现，接收方就应该丢弃这个UDP数据报。

图5.5给出了一个计算UDP校验和的例子。本例中，UDP数据报的长度是15B (不含伪首部)，因此需要添加一个全0字节。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594477063348-b6a39837-22c4-4d78-bf35-d4b798c34104.png)

注意:

1) 校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节，如图5.5所示。但是此字节和伪首部一样，是不发送的。

2) 如果UDP校验和校验出UDP数据报是错误的，那么可以丢弃，也可以交付给上层，但是需要附上错误报告，即告诉上层这是错误的数据报。

3) 通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。这种简单的差错检验方法的检错能力并不强，但它的好处是简单、处理速度快。

### 5.2.3 本节习题（只记录错题和有料）

#### 一、单项选择题

错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594537481996-0d688428-3afc-4cc9-8357-b859d700b5f7.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594537491932-3db9e415-3aa9-4a2b-8a25-575dfea618c8.png)

关键：我给忘了是不可靠了= -、具体看解析



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594537547775-00294f38-df22-4454-a295-85bd7dbeea9a.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594537554827-a0577dd4-b071-4af3-b0d3-dc6d8859af75.png)

关键：校验和和伪首部不应该是可选的么，具体看下图

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594477025177-4066094c-8544-439d-a94f-6810f623c618.png)



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594537677033-cb36fd59-b59c-4b52-a42c-72018bda78cb.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594537685931-6eb29ac6-4acf-4e5b-b485-efc176f006cd.png)

关键：看第二题对的图我看到长度我就以为是了，这里是UDP报文长度，而不是数据报首部长度



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538103393-60724a9c-392f-440a-b735-a5bad3a5facd.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538118926-489c6abd-ff10-4919-b232-5904195f0838.png)

关键：我一开始是想着先填充0在计算校验和，但这里的意思是校验和结果是0，那校验和应该怎么写，具体如解析



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538261685-c3e68058-c8a4-43b2-8f19-b63606023152.png)

​          ![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538269378-6d889dad-7388-42d7-b9e2-a24252b8f6c8.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538294007-e4c2a593-1721-4c0c-b0e7-3e7283f35b00.png)

关键：看看对的和解析，加深印象



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538370946-8226e50e-24cd-4214-894c-2f4c6dd817a7.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538377895-798da923-bb67-4d35-97b7-566bb11c1e22.png)

关键：我就记得远程貌似都可以，就选了A，但这里确实登录的话要保持数据正确，否则登录不上或者登录错误咋整



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538470255-1fd6f9b9-9350-4e19-9cd6-e62a958c0bb4.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538478580-d3cb6dff-3e9d-49f1-aebd-932f11651863.png)

关键：虽然有差错校验，但不能保证可靠传输，校验的只是过程中有没有出错，其他的错误无法检测



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538613050-febc81f0-9ae3-4067-9e5e-fbf9dc8abcd6.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538620586-a27c1c71-fdfa-4464-b614-553ec71760b5.png)

关键：反正就是主要就是端口号，然后分用的话就是好几个只要针对同一个目的端口号即可



#### 二、综合应用题

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538714231-11121eac-3d51-446b-8b5b-e4cd41787e62.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538727434-8e6ee62d-15bf-46da-a311-5f95e8f3c59b.png)

关键：重点就是UDP是针对进程的，最后提到的差错检测也算是优点吧



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538809288-ac0e6bca-8cd7-4d5e-98a8-e5949ba03998.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594538818354-79e67fc3-8b43-48f4-8046-1155d7885931.png)

关键：他这里还是没说到对实时语音数据的传输有什么影响，比如卡顿啊啥的的，这个重传会怎么样确实不清楚



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539077557-35d86ef8-5628-4982-ac54-c56ac3f996bf.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539091833-afaf3216-1f0b-422a-9c2e-235a34c1d163.png)

关键：这里就是涉及到了一个标识字段的含义，倒是感觉和UDP没啥关系



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539161325-af76efce-c5a9-48c1-9e77-f0761847f3c9.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539177977-7178ec11-fd62-42b1-907d-5232dfe80180.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539194847-a511633c-af9c-4080-b21c-10f371a8aeb6.png)

关键：这里又出现了通过端口号猜协议的= -、背！



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539308377-b19e51ee-6aea-4607-94be-cc8eb85506c9.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539314526-bd8e2539-82e7-4668-9669-adf32bc84699.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594539327421-47882d92-c49a-4f30-81fe-6251ecb22803.png)

关键：这里UDP的首部固定为8B，IP数据包首部一般就是20B，然后就是IP中的分片题目了

## 5.3 TCP 协议

### 5.3.1 TCP 协议的特点

TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP是TCP/IP体系中非常复杂的一个协议，主要特点如下:

1) TCP是面向连接的传输层协议。

2) 每条TCP连接只能有两个端点，每条TCP连接只能是点对点的(一对一)。

3) TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。

4) TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。

发送缓存用来暂时存放以下数据：

① 发送应用程序传送给发送方TCP准备发送的数据；

② TCP已发送但尚未收到确认的数据。

接收缓存用来暂时存放以下数据：

① 按序到达但尚未被接收应用程序读取的数据；

② 不按序到达的数据。

5) TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流。

### 5.3.2 TCP 报文段

TCP传送的数据单元称为报文段。一个TCP报文段分为TCP首部和TCP数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中，如图5.6所示。其首部的前20B是固定的。TCP报文段的首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度为4B的整数倍。

TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。

各字段意义如下:

1) 源端口和目的端口字段。各占2B。端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现。

2) 序号字段。占4B。 TCP是面向字节流的(即TCP传送时是逐个字节传送的)，所以TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。

例如，一报文段的序号字段值是301，而携带的数据共有100B，表明本报文段的数据的最后一个字节的序号是400，因此下一个报文段的数据序号应从401开始。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594541567027-6eee9427-650f-45bb-88d9-9588367c7404.png)

3) 确认号字段。占4B，是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认号为N，则表明到序号N- 1为止的所有数据都已正确收到。

例如，B正确收到了A发送过来的一个报文段，其序号字段是501，而数据长度是200B (序号501~700)，这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。

4) 数据偏移(即首部长度)。占4位，这里不是IP数据报分片的那个数据偏移，而是表示首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。

“数据偏移”的单位是32位(以4B为计算单位)。因此当此字段的值为15时，达到TCP首部的最大长度60B。

5) 保留字段。占6位，保留为今后使用，但目前应置为0，该字段可以忽略不计。

6) 紧急位URG。URG= 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。但URG需要和紧急指针配套使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。

7) 确认位ACK。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。

8) 推送位PSH (Push)。 接收TCP收到PSH= 1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满后再向上交付。

9) 复位位RST (Reset)。RST=1时，表明TCP连接中出现严重差错(如主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。

10) 同步位SYN。同步SYN= 1表示这是一个连接请求或连接接收报文。

当SYN=1， ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN=1, ACK=1。即SYN= 1表示这是一个连接请求或连接接收报文。

11) 终止位FIN (Finish)。用来释放一个连接。FIN= 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。

12) 窗口字段。占2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。

例如，假设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的一方还有接收1000B数据(字节序号为701~1700)的接收缓存空间。

13) 校验和。占2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和UDP一样，要在TCP报文段的前面加上12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6，其他的和UDP一样)。

14) 紧急指针字段。占16位，指出在本报文段中紧急数据共有多少字节(紧急数据放在本报文段数据的最前面)。

15) 选项字段。长度可变。TCP最初只规定了一种选项，即最大报文段长度(Maximum SegmentSize, MSS)。MSS是TCP报文段中的数据字段的最大长度。

16) 填充字段。这是为了使整个首部长度是4B的整数倍。

### 5.3.3 TCP 连接管理

TCP是面向连接的协议，因此每个TCP连接都有三个阶段：连接建立、数据传送和连接释放。

TCP连接的管理就是使运输连接的建立和释放都能正常进行。

在TCP连接建立的过程中，要解决以下三个问题:

1) 要使每一方都能够确知对方的存在。

2) 要允许双方协商一些参数 (如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务质量等)。

3) 能够对运输实体资源(如缓存大小、连接表中的项目等)进行分配。

TCP把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。TCP连接的端口称为套接字(socket)或插口。端口拼接到IP地址即构成套接字。

每条TCP连接唯一地被通信两端的两个端点(即两个套接字)确定。

TCP连接的建立采用客户机/服务器方式。主动发起连接建立的应用进程称为客户机(Client)，而被动等待连接建立的应用进程称为服务器(Server)。

#### 1. TCP连接的建立

连接的建立经历以下3个步骤，通常称为三次握手，如图5.7所示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594544858717-485a15de-1af9-48d5-92db-38aa8e26dd4c.png)

第一步：客户机的TCP首先向服务器的TCP发送一个连接请求报文段。 这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号seq=x  (连接请求报文不携带数据，但要消耗一个序号)。

第二步：服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq = y(确认报文不携带数据，但也要消耗一个序号)。确认报文段同样不包含应用层数据。

第三步：当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1，序号字段为x+ 1，确认号字段ack=y+ 1。该报文段可以携带数据，若不携带数据则不消耗序号。

成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。

另外，值得注意的是，服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。

#### 2. TCP连接的释放

天下没有不散的筵席，TCP同样如此。参与TCP连接的两个进程中的任何一个都能终止该连接。TCP连接释放的过程通常称为四次握手，如图5.8所示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594545584419-a6de7e87-57ce-4138-ab26-a6e6c0fb85bd.png)

第一步：客户机打算关闭连接时，向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1，seq=u, 它等于前面已传送过的数据的最后一个字节的序号加1 (FIN报文段即使不携带数据，也要消耗一个序号)。TCP 是全双工的，即可以想象为一条TCP连接上有两条数据通路。发送FIN报文时，发送FIN的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。

第二步：服务器收到连接释放报文段后即发出确认，确认号是ack=u+ 1，而这个报文段自己的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。   

第三步：若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN= 1的连接释放报文段。

第四步：客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack=w+ 1，序号seq=u+ 1。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态。

对上述TCP连接建立和释放的总结如下:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594546081113-6670ff85-5781-4054-88e5-e6e770289c06.png)

### 5.3.4 TCP 可靠传输

TCP的任务是在IP层不可靠的、尽力而为服务的基础上建立一种可靠数据传输服务。TCP提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样。TCP使用了校验、序号、确认和重传等机制来达到这一目的。其中，TCP的校验机制与UDP校验一样，这里不再赘述。

#### 1.序号

TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。

TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。如图5.9所示，假设A和B之间建立了一条TCP连接，A的发送缓存区中共有10B，序号从0开始标号，第一个报文包含第0~2个字节，则该TCP报文段的序号是0，第二个报文段的序号是3。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594546142944-08bae82e-dcca-4558-a8a3-aee3443cf3cd.png)

#### 2.确认

TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。在图5.9中，如果接收方B已收到第一个报文段，此时B希望收到的下一个报文段的数据是从第3个字节开始的，那么B发送给A的报文中的确认号字段应为3。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。

TCP默认使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节。例如，在图5.8中，接收方B收到了A发送的包含字节0~2及字节6~7的报文段。由于某种原因，B还未收到字节3~5的报文段，此时B仍在等待字节3 (和其后面的字节)，因此B到A的下一个报文段将确认号字段置为3。

#### 3.重传

有两种事件会导致TCP对报文段进行重传：超时和冗余ACK。

(1) 超时

TCP每发送一个报文段，就对这个报文段设置一次计时器。 计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。

由于TCP的下层是一个互联网环境，IP 数据报所选择的路由变化很大，因而传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间( Round-TripTime, RTT)。 TCP保留了RTT的一个加权平均往返时间RTTs，它会随新测量RTT样本值的变化而变化。显然，超时计时器设置的超时重传时间(Retransmission Time-Out, RTO)应略大于RTTs，但也不能大太多，否则当报文段丢失时，TCP 不能很快重传，导致数据传输时延大。

(2) 冗余ACK (冗余确认)

超时触发重传存在的一个问题是超时周期往往太长。所幸的是，发送方通常可在超时事件发生之前通过注意所谓的冗余ACK来较好地检测丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认。例如，发送方A发送了序号为1、2、3、4、5的TCP报文段，其中2号报文段在链路中丢失，它无法到达接收方B。因此3、4、5号报文段对于B来说就成了失序报文段。TCP规定每当比期望序号大的失序报文段到达时，就发送一个冗余ACK，指明下一个期待字节的序号[RFC 1122, RFC2581]。在本例中，3、4、5号报文到达B，但它们不是B所期望收到的下一个报文，于是B就发送3个对1号报文段的冗余ACK，表示自己期望接收2号报文段。TCP规定当发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。就前面的例子而言，当A收到对于1号报文段的3个冗余ACK时，它可以认为2号报文段已经丢失。这时发送方A可以立即对2号报文执行重传，这种技术通常称为快速重传。当然，冗余ACK还被用在拥塞控制中，这将在后面的内容中讨论。

### 5.3.5 TCP 流量控制

TCP提供流量控制服务来消除发送方使接收方缓存区溢出的可能性，因此可以说流量控制是一个速度匹配服务(匹配发送方的发送速率与接收方的读取速率)。

TCP提供一种基于滑动窗口协议的流量控制机制，滑动窗口的基本原理已在第3章的数据链路层介绍过，这里要介绍的是TCP如何使用窗口机制来实现流量控制。

在通信过程中，接收方根据自已接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部中的“窗口”字段值，来限制发送方向网络注入报文的速率。同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为拥塞窗口cwnd(后面会讲到)，其大小与网络的带宽和时延密切相关。

例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A。rwnd 即接收方允许连续接收的最大能力，单位是字节。发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd大小之内，保证A不会使B的接收缓存溢出。当然，A的发送窗口的实际大小取rwnd和cwnd中的最小值。

图5.10中的例子说明了如何利用滑动窗口机制进行流量控制。设主机A向主机B发送数据，在连接建立时，B告诉A:“我的接收窗口rwnd =400 (字节)”。

传输层和数据链路层的流量控制的区别是：

传输层定义端到端用户之间的流量控制，

数据链路层定义两个中间的相邻结点的流量控制。

另外，数据链路层的滑动窗口协议的窗口大小不能动态变化，

  传输层的则可以动态变化。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594564657101-66251309-663f-4a8f-811f-8b66a6dc77ee.png)

### 5.3.6 TCP 拥塞控制

所谓拥塞控制，是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。.

拥塞控制与流量控制的区别：

拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

相反，流量控制往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。

例如，某个链路的传输速率为10Gb/s，某巨型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。

但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。

为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下4种算法：慢开始、拥塞避免、快重传、快恢复。

发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP协议要求发送方维护以下两个窗口:

1) 接收窗口rwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在TCP报文的首部的窗口字段通知发送方。

2) 拥塞窗口cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数。

发送窗口的上限值应取接收窗口rwnd和拥塞窗口cwnd中较小的一个，即

发送窗口的上限值= min[rwnd, cwnd]

注意：接收方总有足够大的缓存空间，因而发送窗口大小由网络的拥塞程度决定，也就是说，可以将发送窗口等同为拥塞窗口。

接收窗口的大小可根据TCP报文首部的窗口字段通知发送方，而发送方如何维护拥塞窗口呢？这就是下面讲解的慢开始和拥塞避免算法。

#### 1.慢开始和拥塞避免.

(1) 慢开始算法

在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd= 1，即一个最大报文段长度MSS。每收到一个对新报文段的确认后，将cwnd加1，即增大一个MSS。用这样的方法逐步增大发送方的拥塞窗口cwnd，可使分组注入网络的速率更加合理。

例如，A向B发送数据，发送时A的拥塞窗口为2，那么A 一次可以发送两个TCP报文段，经过一个RTT后(也称一个传输轮次), A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。

使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的慢开始门限ssthresh(阈值)，然后改用拥塞避免算法。

(2) 拥塞避免算法

拥塞避免算法的做法如下：发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍，使cwnd按线性规律缓慢增长(即加法增大)，而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前ewnd的一半(即乘法减小)。

根据cwnd的大小执行不同的算法，可归纳如下:

● 当cwnd < ssthresh时，使用慢开始算法。

● 当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法。

● 当cwnd = ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法(通常做法)。

(3) 网络拥塞的处理

网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生(未按时收到确认，重传计时器超时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完.

拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

慢开始和拥塞避免算法的实现过程如图5.11所示。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594565974940-8dbd257b-b46a-4e45-8bf6-3415efa0ebfc.png)

● 初始时，拥塞窗口置为1，即cwnd=1，慢开始门限置为16， 即ssthresh = 16。慢开始阶段，cwnd的初值为1，以后发送方每收到一个确认ACK, cwnd 值加1，也即经过每个传输轮次(RTT)，cwnd 呈指数规律增长。

● 拥塞窗口cwnd增长到慢开始门限ssthresh 时(即当cwnd = 16时)，就改用拥塞避免算法，cwnd按线性规律加性增长。

● 假定cwnd=24时网络发生拥塞，更新ssthresh的值为12(即变为超时时cwnd值24的一半)，cwnd 重置1，并执行慢开始算法，cwnd= 12时，改为拥塞避免算法。

注意在慢开始(指数级增长)阶段，若2cwnd > ssthresh，则下一个 RTT的cwnd等于ssthresh，而不等于2cwnd，即cwnd不能跃过ssthresh值。如图5.11所示，在第16个轮次时cwnd = 8、ssthresh = 12，在第17个轮次时cwnd= 12，而不等于16。

在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法。“乘法减小”是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh 设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。而“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个RTT)，就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。

#### 2.快重传和快恢复

快重传和快恢复算法是对慢开始和拥塞避免算法的改进。

(1) 快重传

在上一节介绍的TCP可靠传输机制中，快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。

当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。

(2) 快恢复

快恢复算法的原理如下：发送端收到连续三个冗余ACK (即重复确认)时，执行“乘法减小”算法，把慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的不同之处是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。

由于跳过了cwnd从1起始的慢开始过程，所以被称为快恢复。快恢复算法的实现过程如图5.12所示，作为对比，虚线为慢开始的处理过程。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594566731810-85063794-3cbd-4e07-8cea-f7f9c6e7b918.png)

在流量控制中，发送方发送数据的量由接收方决定，而在拥塞控制中，则由发送方自己通过检测网络状况来决定。实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制之中的，当发送方检测到超时的时候，就采用慢开始和拥塞避免，当发送方接收到冗余ACK时，就采用快重传和快恢复。

在本节的最后，再次提醒读者：发送方发送窗口的实际大小由流量控制和拥塞控制共同决定。因此，当题目中同时出现接收端窗口(rwnd) 和拥塞窗口(cwnd) 时，发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。

### 5.3.7 本节习题（只记录错题和有料）

#### 一、单项选择题

有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594567771458-1a4e49fe-ba9c-499d-9f1b-0d0336da7119.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594567790848-c722f84e-f712-4976-ab2e-a5885e9437d2.png)

关键：这题因为和web打过交道所以熟悉，但是拿出来就是警示要背端口号的含义



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594567932164-ce98370f-41d0-47ac-b80b-4327d848f178.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594567943025-48b4b3dd-5510-45ff-ae3c-e23c7f255e73.png)

关键：这题就AD记忆不深，A好像听到过，D这一章貌似都没提到，这里具体要记一下



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568154937-f557db79-cc01-42fe-b847-95abfabc6d04.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568165455-6a906ed2-e139-47f0-b34e-3b1d54876b24.png)

关键：这题我只知道要慢慢捋出来，但是没思路，我太难了，这里貌似没用到快重传和快恢复呀~



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568304261-cb7fa927-5938-4b05-857d-e54661cf51b7.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568313967-9d67fd15-d731-4860-9441-a1230b1ea7f0.png)

关键：也算是拿出来一个看一个区别吧，TCP和UDP首部的区别



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568445914-969c7598-dea0-4948-bd73-23f78a6923da.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568457070-6ba988f1-aed6-4255-820b-a60551fa3ec0.png)

关键：本人选B，我还以为是先目的端口再源端口，是我没记住，然后这个协议字段都要背，可太难了，然后这里的偏移取最大？这个是受TCP最大大小限制么？，估计是这个20~60B的由来，下次记得看一下，我现在懒得翻上去= -、



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568868340-674297aa-3aca-4784-ae70-ba732e680061.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594568881851-cc4b3fd1-6dda-4554-80e0-1909d69119a9.png)

关键：这里就是强调一下发送窗口的含义



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594569135045-53aca842-6fbb-45e6-85f5-1efa3d428e32.png)

   ![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594569149807-f1aa3598-cdc6-4d8b-9fe3-eabb44d53a9f.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594569791973-5da6c1ee-17ac-4e9d-b4b2-8b2fdb1f275a.png)

关键：这个贼细节，要不是我刚看过，不然还真记不住，这个具体看解析，这里还有个末字节序号和报文段编号，因为这个报文段编号可能报文不止一个字节，然后我就编不下去了= -、



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594570544145-40363dbc-2d51-4a73-96b2-ce77cfa0c5a6.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594570555204-a1dbb397-bdbf-4069-a1e3-4770993e1168.png)

关键：本人选B，我以为是发送一个分组后回复，但也确实如果报文段很小那就根本没有分组了，而且一个分组也是一份新的报文段



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594571454876-1d409178-07ef-478b-858d-01b05b3898ec.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594571465321-9c0eaa71-e454-4103-9909-ef4b94e4a4b1.png)

关键：本人选B，我就记得两个窗口的最小值，原来拥塞窗口不是发送方允许的窗口呀，那是啥，还要再查一下，我忘了



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594571597454-35a9b98c-39d5-4152-bf9e-9b80d69e8bd1.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594571607193-84b71d0c-3358-48b0-9ced-353c010a88b8.png)

关键：这个有点细节啊= -、我都分不清楚是哪个控制了= -、



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594619648598-38917405-8a70-4c05-971f-f56fe5daf03e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594619655269-7577a0b6-117e-4f10-9304-fe2562e072e2.png)

关键：这题好选，就是看看细节



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594619758341-e6c52471-2410-4f39-aeb2-cc1948607a31.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594619767680-2d3254b9-ebef-45fd-8016-b20102556a3a.png)

关键：肯定是不能大于发送窗口的大小的，这里就是直接用滑动窗口代表发送窗口



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594619820826-5b6cfc52-7a15-43cd-9618-de88879e9523.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594619835425-9588b0cd-040d-4697-a686-b0b203e6fc3f.png)

关键：先是结合上一题，看起来滑动窗口就指发送窗口，然后这里还去别处了滑动窗口值太大或者太小的影响，具体看解析



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620135726-f0551df3-1fd5-4d30-9804-526710cc48f7.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620144356-6c68db7e-b8dc-4f2e-a249-6f223a466327.png)

关键：第一点就是注意细节，第二就是加深记忆



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620259595-bac94225-4d6f-4985-9a1f-0b74ca047da0.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620269054-c2195c47-a3a9-4828-a63e-f2a8840d1ade.png)

关键：这题就是要捋清楚才能做得了= -、我之前没怎么背，可以看看解析



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620400005-af54887a-ca76-463b-89fc-c613095fc151.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620414827-125d4b2e-6a12-41ec-bba9-243e0ac8307d.png)

关键：刚好结合上一题看一看



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620497533-705a125e-417d-4a3a-8dfe-d7f804ad4a9d.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620507044-52a63e77-b6e8-4f02-8cce-c95179925f85.png)

关键：不会，但是看了解析还是很好理解的



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620609357-46c4ffd9-193e-42e6-b86f-c0b67435cedc.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620618523-24668602-aa22-43cc-b930-4ca6f17660d6.png)

关键：了解FIN标志位的含义和作用，我本来想着全双工的，那应该就是一条线可来可往，那断了就都不行了，现在看来是两条线，只是发送和接受的时间可以同时



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620759650-6a3d190a-718e-49fc-9c99-9e745a19fb8e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620769158-ef70bf9c-f7f1-42d4-996f-69248a64e9bf.png)

关键：目前看到的题目貌似都没出现快恢复和快重传的操作，然后我以为这个是会有陷阱，就是超过门限，但是并没有，解析中还有一句均得到确认，这个是我没考虑到的，是不是说没得到确认的就不加呢？但貌似是的，貌似是每收到一个ACK才能加



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620929506-bce4567f-aaf6-4524-84fc-d77aba6fdbd9.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620940380-5d4d32c1-b131-4bb0-b8a5-a42fa67f5a25.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594620950364-a1482f65-4d6c-4a62-9397-16fd20e1977d.png)

关键：我算出来9次是最骚的= -、原来第一个1算一次= -、我以为一次传输就直接变成2了，涨姿势了= -那去掉两个1那就是7没问题了



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621077830-42b39b08-56cf-45c0-8ec7-61efe211fb02.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621087152-e5bbfa6c-8ebc-4ab3-9efc-3262beee492a.png)

关键：卧槽，这里就出现了快恢复算法，原来出现这个算法的特征说法是收到3个冗余ACK报文= -、涨姿势了，虽然以前看过，但根本没往心里去，而且这个快恢复原来是恢复成延迟时门限的一半= -、我以为是另一个变量的一半，但想想也没啥好给他一半了



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621238225-9e6b25e5-0b75-425a-a989-7ede9d067ca6.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621247358-a7ee88d8-008b-474b-8750-2826289b6915.png)

关键：这里应该就是两个窗口大小取最小值的例子，但也要知道窗口字段的值的含义是什么



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621676089-36040522-273e-4951-bf14-a6dd728051c7.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621685402-c0c628aa-fdf3-4bf3-b69e-be2bb29ab794.png)

关键：我傻了= -、我还把第一个2KB也算进去了= -、也是来回完就生了，和上面那题不太一样，看了下貌似也差不多= -、都是时间= -、算了，具体遇到在捋一捋问的是什么



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621841103-cf2f2709-38f2-4bbb-8553-26e6d8e39515.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594621850757-f310f795-3965-41f5-84db-6183615ce9ad.png)

关键：这里就是累加= -、但是我有疑问就是他的首部去哪里了？如果有效负载包含首部，那应该200是第一个数据的序号，那首部可以省略，但+应该加的少于300，然后再加个包含首部和数据的500，然后下一个才行，但如果有效负载不包含首部，那应该要额外加才行



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622076583-ff2294db-d161-4b43-939d-06010d6975ee.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622085599-87439242-5b49-48c9-9f42-7dc084783da9.png)

关键：卧槽，天秀，没收到，那主机甲只知道你发的接收窗口大小为2000B啊= -、你怎么知道另一个没收到所以只能发1000？



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622190327-ecdef2a6-9a7d-4dc7-8749-adacfb336221.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622201372-20a7af38-1cab-4a54-bed2-042795e39db2.png)

关键：我就拿出来是想看看这个seq的值怎么算，就这一个不确定，但燕来这个毫无关系，随意给出的啊= -、等于说是不影响



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622305158-bd478816-df93-48cc-9149-a07bdbe9756c.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622322898-20c468f8-160d-440b-940d-40a0913d870b.png)

关键：其实这一种的我就不是很明白，我记得之前还有个发了3那就不用管2的，可能是协议不太一样吧，这个需要每一个都确认



有料：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622420169-41e5fc0b-735d-4eb3-b8dd-59bd1863e857.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622428797-5e812384-3974-4cc0-b5a6-28a4c3e0436e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622438409-b23ffb76-956c-4148-bd3a-6f3ed736cd26.png)

关键：这题就是要捋清楚即可，不懂得可以再看看



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622495682-867dd2b5-494a-467c-bda6-2cc50443c3a0.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622506339-07b52229-8c07-4ee1-bc0c-a0ed46a31401.png)

关键：这个在前面没有提到过，具体解释如解析，可以了解一下或者背一下



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622588904-6f93311f-b6f4-47da-9822-704f91a8fac1.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622597706-df20629b-4dab-4ced-917f-5e96aec9c686.png)

关键：原来这题玩的是缓存的内容= -、是受到了接收窗口大小的限制，而且他都不删的，就是不被取走那句话= -、但如果满了然后呢？他这里就没说，不可能4个RTT之后还一直满的吧，第一个RTT的总会让出来吧



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622793026-c4b632ef-a999-4d75-a32d-f12f0ea26a06.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622807495-7d498176-defd-47ca-bd06-3c1b05d11ee8.png)

关键：这题没思路呀，看到答案就蒙了，怎么会这么多，但原来这个25是5个RTT*TRR的时间，我就说怎么答案的数字都这么大



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622927821-fca960f1-8ae9-4b3f-b2ff-1f579c15649c.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622971404-14b24f39-895b-4b65-b57b-7845f4a193c2.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594622938741-1c1b72c2-6802-44f2-9be7-8b0f731cd329.png)

关键：也是，我给忘了那个3个ACK了= -、明明刚做题还遇到了= -、这个要加深记忆，这里也没有说明超时计时器相关的，那就是和ACK有关了



错题：![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623026184-91c7f1cc-4f56-479d-8623-68b8bf7ac37f.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623035657-fbbd3254-f9ae-4fd9-843c-8528a276d5ef.png)

关键：这个是个记忆小技巧吧，具体还是要背三次握手的原理和过程

#### 二、综合应用题

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623092686-246838a6-a801-41d6-871f-1c806b62321e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623104016-5502cbd1-1a9f-47bc-8154-aea4902a2ad5.png)

关键：这里又是能直接确认了？可以跳着来了？他怎么知道是丢失了还是后面的确认了？



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623262538-d3171873-6dcb-4179-a02f-d34d171caf7f.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623272490-5a6096b3-8754-48b2-8b22-dd68fbfa5abc.png)

关键：具体就如解析，就是对两种方法的一种剖析



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623343762-22ad944a-0851-4d68-8e76-6a1952322e23.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623353055-de90e915-6c33-4251-bb7e-93ab148730b9.png)

关键：= -？数据的这一部分都不要考虑首部的么？我蒙圈了，还是说这个其实不是分组？只是把几个数据放在同一个TCP报文中？



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623474698-1481c28e-9951-43d4-a3ba-d13d40c909a8.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623485148-37f9f0a0-fc0c-4a14-b191-510240c1044e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623494317-fd8201a9-50cd-4361-9bc3-2e756cd9afc4.png)

关键：这个吞吐量就是一秒能发送的数据的大小= -、



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623565801-7539cccc-4796-470e-8b86-618fec98fe4c.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623574500-2143cca7-8574-4a1b-9781-35e85f50e800.png)

关键：卧槽？这个貌似上面没有讲过啊= -、虽然这里讲的听清楚还有例子了，但不一定能记住



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623732200-91d96796-4ee3-4fc9-a6cc-76a47d889f64.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623741634-e75aaf7c-c6d1-4142-b5e1-951f81f3bdc6.png)

关键：这个有点东西，解释的还算清楚，但如果要求弄懂原理，比如怎么分配这个序号让他不重复，那还要另外研究一下



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623843823-996977b4-2a8d-4f27-89bf-05aaa92b10ed.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594623855078-73273baa-f6a2-444b-9653-f96beba0462d.png)

关键：搜嘎，这里RTT还要另外算，算是一个小陷阱，还有一个线路效率，就是要注意单位的转换了，以及题目中的大B和小b



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594624025903-9ce0c6cb-6c19-4c9b-ab22-df0227fb9e25.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594624036028-2e1c2b9e-2f42-4811-a15d-b21aaf613e90.png)

关键：我还以为要乘以8B呢，那看来这个序号和之前的网络以下的不太一样啊，

原来这里有个策略的问题，累计策略就要全部验证？



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594625799424-93ef7999-ceae-4ed5-a3f7-75fd56ce070d.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594625811692-3bd45506-8562-47c7-b9ad-ffe0ed746cdb.png)

关键：这里4，可能是收到第4个后就能变成24，就能发送了，而不用等到他的确认回来，前面估计是又解释了一遍，可以再看看



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594625998350-1d767017-c7d9-403d-8854-0ee0725b0599.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594626020210-681f9c5d-2224-40c0-a4e5-d7bdff5ed578.png)

关键：这次得到还是算在了其中，确实，他是从慢启动开始计算



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594626147459-fcdaa386-9d7d-48a7-ac5e-ebd918c7015e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594626169248-747d1e17-266d-46b9-abd9-aecba7ab183e.png)

关键：新颖的一题，这里还要了解报文的格式，不然不会清楚序列号为32位，然后以太网的开销我就蒙了= -、我还以为是20B呢还，这题貌似上面也有类似的，但是问法不一样，这里的关键就是弄清楚每个报文的发送大小



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594627523908-3eae089b-9f82-4b49-b17e-ec65f0d81363.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594627619488-7b99e5b1-e4e2-444f-a376-f8cad4161ee3.png)

关键：这个*1000就很骚··原来这个k不是1024的意思，我老是记错了，但他在题目里说是一半，但公式里还是乘2了，所以不清楚具体过程是怎么样的



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594627891211-9bbf1c54-eb8b-46d4-b2b6-42b69ed0a84a.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594627901097-87294d72-625d-45dd-a30e-6781482bf538.png)

关键：选择题常见题



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594627983415-2773417e-dad8-4794-b3e3-91d17fd3f04e.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594627995326-ca6a312c-f09c-42b4-a8ec-3d1adc732f37.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594628015610-5e5aa77c-4873-4661-b072-483e79d0241b.png)

关键：这题就是看图数位子，重点就是第一个长度单位，类似于这个首部长度的单位是4B，还要记端口号是什么，是什么协议的，像这里第四题还要看几个表示的值和含义



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594628298117-5f17d84b-2a4e-4ec0-8a25-458f055df4d9.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594628309834-b022f6f3-0e89-4033-9829-80c30dcdf67d.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594628320323-83cc46ae-fdf5-4cd2-95d7-1429de5fc315.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594628682832-0bf73b30-cc50-43dc-9baa-2ad361a73f75.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594628693703-f7f45e77-766f-4a4d-a4f6-1cba46a3a0f0.png)

关键：这题就是看图数数

第一题就是要理解每个标识的意思以及作用，这里还涉及填充，就需要背最小长度

第二题这个还要通过题目去看初始序号= -、这个不清楚怎么看的，可能是因为3号的最小吧，还是说通过表2来找的，但那个是第三题这个贼骚，我以为是数有几个IP。没想到是先看S发出的是哪个分组，然后通过分组的TTL来看减少了多少，就是跳了几次，具体这些值怎么来的还要在分析，我就懒得看了



![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594629628828-5cd2a146-c932-4142-afaf-f2342e72083a.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594629646629-6092525e-69f6-41e0-aa0b-b38b855bc2e3.png)

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594630595894-115e4133-cb29-446e-9422-d21c4b66759c.png)

关键：第一题就正常两个1，序号的话就是初始序号下一个，因为想要得到下一个

第二题我是一天都不知道他这个值哪里来的= -、12就不知道哪里来的，这题有大问题= -、完全不会··可能等下次做到要去百度，网上的解析确实更清楚一点，如上图，但其中还有一个每收到一个新报文拥塞窗口就+1，而不是翻倍，这个题目里也没看到解释

第三题就是要算出来传输了多少，而且这里的注意里总算解答了我的疑惑，原来是大小写的区别，然后这里的5我也不清楚哪里来的的，5次就到了阈值么？然后网上的解答给出了答案，是发送第一个到发送窗口等于0的次数

第四题也是网上的答案回答的更仔细，但为什么是1.5，因为RTT就是一个来回了，等于2，所以1.5*2就是3了



## 5.4 本章小结及疑难点

### 1. MSS设置得太大或太小会有什么影响?

规定最大报文段MSS的大小并不是考虑到接收方的缓存可能放不下TCP报文段。实际上，MSS与接收窗口没有关系。TCP的报文段的数据部分，至少要加上40B的首部(TCP首部至少20B和IP首部至少20B)，才能组装成一个 IP数据报。若选择较小的MSS值，网络的利用率就很低。设想在极端情况下，当TCP报文段中只含有1B的数据时，在IP层传输的数据报的开销至少有40B。这样，网络的利用率就不会超过1/41。到了数据链路层还要加上一些开销，网络的利用率进一步降低。但反过来，若TCP报文段很长，那么在IP层传输时有可能要分解成多个短数据报片，在终端还要把收到的各数据报片装配成原来的TCP报文段。传输有差错时，还要进行重传。这些都会使开销增大。

因此，MSS应尽量大一些，只要在IP层传输时不要再分片就行。由于IP数据报所经历的路径是动态变化的，在一条路径上确定的不需要分片的MSS，如果改走另一条路径，就可能需要进行分片。因此，最佳的MSS是很难确定的。MSS的默认值为536B，因此在因特网上的所有主机都能接收的报文段长度是536 + 20xTCP固定首部长度= 556B.

### 2.为何不采用“三次握手”释放连接，且发送最后一次握手报文后要等待2MSL的时间呢?

原因有两个:

1) 保证A发送的最后一个确认报文段能够到达B。如果A不等待2MSL，若A返回的最后确认报文段丢失，则B不能进入正常关闭状态，而A此时已经关闭，也不可能再重传。

2) 防止出现“已失效的连接请求报文段”。A在发送最后一个确认报文段后，再经过2MSL可保证本连接持续的时间内所产生的所有报文段从网络中消失。造成错误的情形与下文(疑难点6)不采用“两次握手”建立连接所述的情形相同。

注意：服务器结束TCP连接的时间要比客户机早一些，因为客户机最后要等待2MSL后才可进入CLOSED状态。

### 3.如何判定此确认报文段是对原来的报文段的确认，还是对重传的报文段的确认?  

由于对于一个重传报文的确认来说，很难分辨它是原报文的确认还是重传报文的确认，使用修正的Karm算法作为规则：在计算平均往返时间RTT时，只要报文段重传了，就不采用其往返时间样本，且报文段每重传一次， 就把RTO增大一些。

### 4. TCP使用的是GBN还是选择重传?

这是一个有必要弄清的问题。前面讲过，TCP 使用累计确认，这看起来像是GBN的风格。但是，正确收到但失序的报文并不会丢弃，而是缓存起来，并且发送冗余ACK指明期望收到的下一个报文段，这是TCP方式和GBN的显著区别。

（下面这个推荐看一下，特别是像我一下不理解到底是累计重传还是可以跳着来的）

例如，A发送了N个报文段，其中第k (k<N)个报文段丢失，其余N- 1个报文段正确地按序到达接收方B。

使用GBN时，A需要重传分组k，及所有后继分组k+ 1,k+2,"",N。

相反，TCP却至多重传一个报文段，即报文段k。

另外，TCP中提供一个SACK (Selective ACK)选项，即选择确认选项。使用选择确认选项时，TCP看起来就和SR非常相似。因此，TCP的差错恢复机制可视为GBN和SR协议的混合体。

### 5.为什么超时时间发生时cwnd被置为1， 而收到3个冗余ACK时cwnd减半?

大家可以从如下角度考虑。超时事件发生和收到3个冗余ACK，哪个意味着网络拥塞程度更严重？通过分析不难发现，在收到3个冗余ACK的情况下，网络虽然拥塞，但至少还有ACK报文段能被正确交付。而当超时发生时，说明网络可能已经拥塞得连ACK报文段都传输不了，发送方只能等待超时后重传数据。因此，超时时间发生时，网络拥塞更严重，那么发送方就应该最大限度地抑制数据发送量，所以cwnd置为1；收到3个冗余ACK时，网络拥塞不是很严重，发送方稍微抑制一下发送的数据量即可，所以cwnd减半。

### 6.为什么不采用“两次握手”建立连接呢?

这主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误。考虑下面这种情况。

客户A向服务器B发出TCP连接请求，第一个连接请求报文在网络的某个结点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接。而此时，前一个滞留在网络中的连接请求到达服务器B，而B认为A又发来连接请求，此时若使用“三次握手”，则B向A返回确认报文段，由于是一个失效的请求，因此A不予理睬，建立连接失败。若采用的是“两次握手”，则这种情况下B认为传输连接已经建立，并一直等待A传输数据，而A此时并无连接请求，因此不予理睬，这样就造成了B的资源白白浪费。

### 7. 是否TCP和UDP都需要计算往返时间RTT?

往返时间RTT仅对传输层TCP协议才很重要，因为TCP要根据RTT的值来设置超时计时器的超时时间。

UDP没有确认和重传机制，因此RTT对UDP没有什么意义。

因此，不能笼统地说“往返时间RTT对传输层来说很重要”，因为只有TCP才需要计算RTT，而UDP不需要计算RTT.

### 8.为什么TCP在建立连接时不能每次都选择相同的、固定的初始序号?

1) 假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。

2) 假定每次建立连接时，主机A都选择相同的、固定的初始序号，如选择1.

3) 假定主机A发出的某些TCP报文段在网络中会滞留较长时间，以致主机A超时重传这些TCP报文段。

4) 假定有一些在网络中滞留时间较长的TCP报文段最后终于到达主机B，但这时传送该报文段的那个连接早已释放，而在到达主机B时的TCP连接是一条新的 TCP连接。

这样，工作在新的TCP连接的主机B就有可能会接收在旧的连接传送的、已无意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在当前新连接所用的序号范围之中)，结果产生错误。

因此，必须使得迟到的TCP报文段的序号不处在新连接所用的序号范围之中。

这样，TCP在建立新的连接时所选择的初始序号一定要和前面的一些连接所用过的序号不同。因此，不同的TCP连接不能使用相同的初始序号。

### 9.假定在一个互联网中，所有链路的传输都不出现差错，所有结点也都不会发生故障。试问在这种情况下，TCP的“可靠交付”的功能是否就是多余的?

不是多余的。TCP的“可靠交付”功能在互联网中起着至关重要的作用。至少在以下的情况下，TCP的“可靠交付”功能是必不可少的。

1) 每个IP数据报独立地选择路由，因此在到达目的主机时有可能出现失序。

2) 由于路由选择的计算出现错误，导致IP数据报在互联网中转圈。最后数据报首部中的生存时间(TTL)的数值下降到零。这个数据报在中途就被丢失。

3) 某个路由器突然出现很大的通信量，以致路由器来不及处理到达的数据报。因此有的数据报被丢弃。.

以上列举的问题表明：必须依靠TCP的“可靠交付”功能才能保证在目的主机的目的进程中接收到正确的报文。

### 本章的知识架构图如下:

![image.png](https://cdn.nlark.com/yuque/0/2020/png/359941/1594650170841-34042db1-d70f-4c37-b556-5082764f7455.png)