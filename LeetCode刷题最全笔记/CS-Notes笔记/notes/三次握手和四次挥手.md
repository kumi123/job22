![这里写图片描述](https://cdn.jsdelivr.net/gh/kumi123/CDN//img/20170823152010213)



一、TCP三次握手
如上图：
第一次握手：
建立连接。客户端发送连接请求报文段，==将SYN位置为1，Sequence Number为x==；然后，客户端进入==SYN_SEND状态，等待服务器的确认==；

第二次握手：
服务器收到SYN报文段。==服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；==服务器端将上述所有信息放到一个报文段（即==SYN+ACK报文段==）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

第三次握手：
==客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段（注意只有ACK报文段），这个报文段发送完毕以后(无论服务器是否应答），客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。==

二、TCP四次挥手
第一次挥手：
主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，==主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了==；

第二次挥手：
主机2收到了主机1发送的FIN报文段，向==主机1回一个ACK报文段==，==Acknowledgment Number为Sequence Number加1==；==主机1进入FIN_WAIT_2状态；==主机2告诉主机1，我“同意”你的关闭请求；

第三次挥手：
==主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态==；

第四次挥手：
主机1收到主机2发送的FIN报文段，==向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接==；此时，==主机1等待2MSL后依然没有收到回复==，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

三、为什么要三次握手？
为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

谢希仁《计算机网络》书中的举例：
“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以==致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。====但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了==。==采用“三次握手”的办法可以防止上述现象发生==。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

所以主要==目的防止server端一直等待，浪费资源==。

四、为什么要四次挥手？
==TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送，之后就会中断这次TCP连接。==

四次挥手过程的状态变化：
FIN_WAIT_1:
其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）

FIN_WAIT_2：
实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）

CLOSE_WAIT：
这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。==所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。==（被动方）

LAST_ACK:
它是==被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。==（被动方）

TIME_WAIT:
==表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。==如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）

CLOSED:
表示连接中断。