

## 秒杀架构设计理念

- 限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。

- 削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有==利用缓存和消息中间件等技术==。


- 异步处理：秒杀系统是一个高并发系统，采用==异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式==。


- 内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于==数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升==。


## 秒杀系统架构设计思路
- ==将请求拦截在系统上游，降低下游压力==：秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，最终请求超时。
- 利用缓存：利用==缓存可极大提高系统读写速度==。
- 消息队列：==消息队列可以削峰，将拦截大量并发请求==，这也是一个异步处理过程，==后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理==。

## 使用技术
前端：Thymeleaf、Bootstrap、JQuery
后端：SpringBoot、Mybatis
中间件：RabbitMQ、Redis、Druid
注：Thymeleaf其实是一个服务端的模板；RabbitMQ实现异步下单；使用redis做缓存（相比较于Memcached有比较多的一些优点，Redis可以做持久化）；druid：阿里巴巴开发的连接池，好处：可以做监控，监控连接池里面的连接、最大连接多少、最大并发多少、最长的时间等特性。

## 主要项目技术描述
- 使用分布式Seesion，让多台服务器可以响应。
- 使用redis做缓存提高访问速度和并发量，减少数据库压力。
- 使用页面静态化，缓存页面至浏览器，前后端分离降低服务器压力。
- 使用消息队列完成异步下单，提升用户体验，削峰和降流。
- 安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。
  
  

## 集成Thymeleaf做页面模板（引入依赖就可以）

​	Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 

​	Thymeleaf 在有网络和无网络的环境下皆可运行，这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。

  本质上就是HTML模板引入这个Thymeleaf ，用来渲染。controller层返回相应参数到html就可以


## 关于数据库设计的思考

​	                     商品表，秒杀商品表，订单表，秒杀订单，用户表

#### 秒杀商品表和商品表分开。

- 原因：每次秒杀活动都会操作数据库，修改秒杀商品的字段，因为每次秒杀时候。对应的秒杀时间段，秒杀实现，秒杀功能，价格等都不同，商品表不易于维护。
- 而且，秒杀商品的个数和普通商品的个数是独立计算的，不同于普通商品的库存字段。



## 连接Redis并且定义工具类方便使用
public T get(KeyPrefix prefix,String key,Class data) 根据key取得缓存中值（根据传入的前缀）

public boolean delete(KeyPrefix prefix,String key) 删除key
public boolean set(KeyPrefix prefix,String key,T value) 根据key设置缓存中值
public Long decr(KeyPrefix prefix,String key) 自减
public Long incr(KeyPrefix prefix,String key) 自增
public boolean exitsKey(KeyPrefix prefix,String key) 是否存在key
public static T stringToBean(String s,Class clazz)
public static String beanToString(T value)

- 但是其中，==存入redis 的是String类型，这个时候我们的数据不一定是String类型，所以需要类型转换，将数据转换成String格式存入。==

- ==BeanToString()这个方法，就是来转化，先获取传入数据的Class类型，根据类型判断，int,long,String 类型，通过API转换直接转换成String即可，或是其他的自定义对象，则利用fastjson库将我们项目中定义的JavaBean 对象，转化为json字符串。==

- StringToBean() 相当于上个是反方法。都需要传入一个类型，这样才知道将字符串转换为什么对象。

## 给每一个模块名字增加不同前缀

**为什么要这个通用缓存Key？
当项目中的模块越来越多的时候，需要存的缓存也越来越多，比如商品Id,订单Id，用户id等,此时若是id出现重复，将给系统带来错误。**

**那么使用KeyPrefix来更好的操作和管理缓存中对应的key。给不同模块的key带有一个前缀。**



## 两次MD5加密进行

做两次MD5加密的目的

==前端：pwd=MD5（明文+固定salt）==
==后端：pwd=MD5（第一次加密后的密码+随机salt）==

第一次 （在前端加密）：密码加密是（明文密码+固定盐值）生成MD5用于传输，目的是由于http是明文传输，当输入密码若直接发送到服务端进行验证，此时如果被截取将可以直接获取到明文密码，获取用户信息；加盐值是为了混淆密码，原则就是明文密码不能在网络上传输
第二次（在后端加密）：服务端接收到已经用MD5加密的密码后，我们并没有直接存到数据库里面，而是生成一个随机的salt，跟用户输入的密码一起拼装，再做一次MD5加密，然后再把得到的密码存在数据库里面

第二次加密的目的：防止数据库被入侵，被人通过彩虹表反查出密码，所以服务端接受到密码后，也不是直接写入到数据库，而是生成一个随机盐(salt)，再进行一次MD5加密后存入数据库

[具体实现](https://blog.csdn.net/weixin_42687829/article/details/104432048?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242)



## JSR303参数校验
​	JSR 303 用于对Java Bean 中的字段的值进行验证,使得验证逻辑从业务代码中脱离出来。是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。
​	可以直接使用@NotNull、@Length(min=32)等注解对实体类进行验证，避免重复的校验代码，只需在传入的参数上打上注解就可以进行参数校验，避免代码冗余。

​	自定义是否是手机号的验证器  核心就是`Pattern mobile_pattern=Pattern.compile("1\\d{10}");*//1开头，然后10个数字，那么正确的手机号*`



## 全局检验拦截
JSR303校验器后，校验不通过都会产生一个BindException( org.springframework.validation.BindException)和一大串错误信息（其中就包括校验的处理信息）。若要对异常处理，我们可以定义一个全局异常处理的拦截器。

好处：可以实现对项目中所有产生的异常进行拦截，在同一个类中实现统一处理。避免异常漏处理的情况。

全局异常处理场景：先检查异常类型，若是我们业务异常，返回即可。业务中发现异常直接抛出我们自定义的异常即可。


## 分布式session
​	用户登录成功之后，给这个用户生成一个sessionId(用token来标识这个用户)，将token和用户绑定在一起放在缓存当中。将token写到cookie中，传递给客户端。然后客户端在随后的访问中，都在cookie中上传这个token，然后服务端拿到这个token之后，就根据这个token从缓存来取得对应的用户信息。token利用uuid生成。

## 详情页面实现（包含倒计时）
- 后端根据商品的Id去数据库中获取秒杀开始时间和结束时间，以及系统当前时间，并定义秒杀剩余时间变量remailSeconds和秒杀状态status，计算出相应的值，传给前端，前端拿到之后，做相对应的显示逻辑效果。
- 前端需要获取status和remailSeconds（即秒杀状态和剩余时间变量），定义个一个属性为隐藏的input来接收remainSecode ，并且定义标签来判断status的状态，通过这个值来显示是否开始秒杀，秒杀正在进行中，以及秒杀结束。
- 需要自己写一个方法来控制秒杀按钮的的可以点击与不可点击的情况，没开始的时候按钮，不可点击，开始后显示按钮，此时可以点击，但是结束也不可点击。并且从倒计时状态到正在进行秒杀状态的时候要动态切换文案
- 使用setTimeout函数，setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。这里是1000毫秒，即每过一秒，将remianSecond 值减一，并设置到显示text中（即实现倒计时动态效果），然后在调用coutDown，判断此时是否结束此状态（remailSeconds==0），结束调用

## 压力测试

- **启动系统，先生成1000个用户并且存储至数据库**
- **让每个用户登录到系统，并且生成与其对应token信息，将用户与token信息存储到文件里面去，这时候缓存里边也有这些。压力测试就是用这些用户和对应的token去模拟登陆**
- 开始压测  新建一个CVS Data:  配置相应的信息(将tokens.txt文件导入)，多线程组启动模拟多用户秒杀
- 按照秒杀接口来进行秒杀同时

 

## 页面优化技术

1. **页面缓存+URL缓存+对象缓存**
   由于并发瓶颈在数据库，想办法如何减少对数据库的访问，所以加若干缓存来提高，通过各种粒度的缓存，最大粒度页面缓存到最小粒度的对象级缓存。

1. **CDN优化**
   内容分发网络，就近访问。

缓存淘汰策略

淘汰策略
FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。

LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。

LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。

- 页面缓存

  比如当访问goods_list页面的时候，如果从缓存中取到就返回这个html,(这里方法的返回格式已经设置为text/html，这样就是返回html的源代码)，如果取不到，利用ThymeleafViewResolver的getTemplateEngine().process和我们获取到的数据，渲染模板，并且在返回到前端之前保存至缓存里面，然后之后再来获取的时候，只要缓存里面存的goods_list页面的html还没有过期，那么直接返回给前端即可。

- URL缓存
  这里的url缓存相当于页面缓存，针对不同的详情页显示不同缓存页面，对不同的url进行缓存

- 对象缓存

  MiaoshaUserService里面增加getById方法，先去取缓存，如果缓存中拿不到，那么就去取数据库，然后再设置到缓存中去

**策略：**

1. **首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。**
2. **需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。**

**1. 对删除缓存进行重试，数据的一致性要求越高，我越是重试得快。
\2. 定期全量更新，简单地说，就是我定期把后再全量加载。
\3. 给所有的缓存一个失效期。**



## 秒杀优化

【秒杀系统的接口优化之异步下单】
问题：
  针对秒杀的业务场景，在大并发下，仅仅依靠页面缓存、对象缓存或者页面静态化等还是远远不够。数据库压力还是很大，所以需要异步下单，如果业务执行时间比较长，那么异步是最好的解决办法，但会带来一些额外的程序上的复杂性。

思路：

系统初始化，把商品库存数量stock加载到Redis上面来。
后端收到秒杀请求，Redis预减库存，如果库存已经到达临界值的时候，就不需要继续请求下去，直接返回失败，即后面的大量请求无需给系统带来压力。
判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品，判断是否重复秒杀。
库存充足，且无重复秒杀，将秒杀请求封装后消息入队，同时给前端返回一个code (0)，即代表返回排队中。（返回的并不是失败或者成功，此时还不能判断）
前端接收到数据后，显示排队中，并根据商品id轮询请求服务器（考虑200ms轮询一次）。
后端RabbitMQ监听秒杀MIAOSHA_QUEUE的这名字的通道，如果有消息过来，获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）。
此时，前端根据商品id轮询请求接口MiaoshaResult,查看是否生成了商品订单，如果请求返回-1代表秒杀失败，返回0代表排队中，返回>0代表商品id说明秒杀成功。
返回结果说明：
前端会根据后端返回的值来判断是秒杀结果。
  -1 ：库存不足秒杀失败
   0 ：排队中，继续轮询
   >0 ：返回的是商品id ，说明秒杀成功
[【SpringBoot商城秒杀系统项目实战21】高并发秒杀系统接口优化 RabbitMQ异步下单_pitt1997的博客-CSDN博客](https://blog.csdn.net/Brad_PiTt7/article/details/90700273)



## 生成秒杀地址

​	每次点击秒杀按钮，才会生成秒杀地址，秒杀地址不是写死的，是从服务端获取，动态拼接而成的地址。

​	具体：

- 进行秒杀之前，去后端获取一个动态的秒杀地址path（服务端生成随机数作为path,并且用这个MD5进行加密），并且将随机path写入缓存，**在然后将这个随机path返回给前端，前端用这个path拼接在新的请求url(url : “/miaosha/” + path + “/do_miaosha”)上作为参数，再去发请求到后台开始秒杀。
- 后端接收到这个请求秒杀地址path参数，并且与缓存中的存的path比较，如果一致，进行秒杀逻辑，否则，非法请求。
- 缺点：**使用动态获取秒杀地址，只有真正点击秒杀按钮，才会根据用户id和商品goodsId生成对应的秒杀接口地址**，仍然不能解决利用机器人频繁点击按钮的操作，为了降低点击按钮的次数，以及高并发下，防止多个用户在同一时间内，并发出大量请求，加入**数学公式图形验证码以及接口防刷等优化技术。**

## 减少用户请求的同时大量涌入

​	高并发下场景，在刚刚开始秒杀的那一瞬间，迎来的并发量是最大的，减少同一时间点的并发量，将并发量分流也是一种减少数据库以及系统压力的措施

​	**点击秒杀之前，先输入验证码，分散用户的请求。具体实现是服务端生成类似1+2-3的验证码，把结果计算出来存至服务端redis（缓存），把验证码图片发至客户端，此后客户端在请求秒杀地址前输入验证码值发请求验证，（去缓存里面取得值验证是否与用户输入相同），验证通过才会动态生成秒杀地址给前端。**

## 接口限流防刷

​	**限制同一个用户一秒钟或者一分钟之内只能访问固定次数，在服务端对系统做一层保护**

具体：

​	1、获取访问路径
​	2、拼接用户用户的Id作为一个记录该用户访问次数的key

​    3、缓存里面取得该key，做判断，如果缓存里面没有取到，代表是第一次访问，所以给缓存设置该key，并设置初始值value为1。

​    4、如果缓存里面取得值并且小于5，那么直接将该key对应的值value+1，如果缓存里面的次数大于超过4（>=5），那么代表在限制时间内（在缓存还没	有失效的时间内），访问次数达到限制。

​		本项目设置的固定有效期为5s，也就是说5秒之内最多可以点击访问5次。

