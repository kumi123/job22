# [Java面试题之 -----面向切面编程](https://www.cnblogs.com/xuxinstyle/p/9367074.html)

**这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。**

>  

> ​    面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而==封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配==。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。
> 但是人们也发现，在==分散代码的同时，也增加了代码的重复性==。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是==因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来==。
> 也许有人会说，那好办啊，我们==可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类==。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？**这种==在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程==。** 

> **
> **    一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。
> 这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。
> AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。

> 切面编程的一些概念解释如下。
>
> 切面（Aspect）：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中==通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的==。
>
> 通知（Advice）：是==切面的具体实现==。以目标方法为参照点，根据==放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）==5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。
>
> 连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。
>
> 切入点（Pointcut）：==用于定义通知应该切入到哪些连接点上==。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。
>
> 目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。
>
> 代理对象（Proxy）：==将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能==。代理对象对于使用者而言是透明的，是程序运行过程中的产物。
>
> 织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。
>
> ### 切面组件Aspect
>
> 切面组件一般是登录检查、日志记录、事务管理等
> xml配置中先声明bean，再在==aop:config的aop:aspect中指定为切面==
> [或者用@Aspect注解指定](mailto:或者用@Aspect注解指定)
>
> ### 通知advice
>
> 通知就是：在调用目标方法的什么时候调用切面组件的方法，可以是：
> 前置通知：@Before，方法调用之前
> 后置通知：@AfterReturning，方法正常返回
> 异常通知：@AfterThrowing，方法调用过程中出现异常
> 最终通知：@After，不管方法是正常返回还是出现异常，这个通知都会调用，因此必须这两种可能的情况
> 环绕通知：@Around，
>
> ### 切入点
>
> 切入点就是要在==哪些类的哪些方法上进行切入==，可以限定一些类下的所有方法，或者不同类下的一些方法，或者指定类下的指定方法
> 方法限定表达式：
>   基本模式：execution([修饰符] 返回值类型 方法名(参数) [异常类型])。具体见Spring Reference 4.3.6版第223页
>   execution(public * * (..))：所有 的public方法
>   execution(* set*(..))：以set打头的任意方法
>   execution(* com.xyz.service.SomeService.*(..)：SomeService类下的任意方法
>   execution(* com.xyz.service.*.*(..))：service包下的任意类的任意方法
> 类型限定表达式：
>   within(com.xyz.service.*)：service包下的任意类下的任意方法，不包含子包
>   within(com.xyz.service..*)：包含子包