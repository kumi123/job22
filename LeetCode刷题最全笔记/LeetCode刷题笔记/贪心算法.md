### **贪心算法概念叙述**

运用贪心算法求解问题时，会将问题分为若干个子问题，可以将其想象成俄罗斯套娃，利用贪心的原则从内向外依次求出当前子问题的最优解，也就是该算法不会直接从整体考虑问题，而是想要达到局部最优。只有内部的子问题求得最优解，才能继续解决包含该子问题的下一个子问题，所以前一个子问题的最优解会是下一个子问题最优解的一部分，重复这个操作直到堆叠出该问题的最优解。

贪心算法最关键的部分在于贪心策略的选择，贪心选择的意思是对于所求问题的整体最优解可以通过一系列的局部最优选择求得。而必须注意的是，贪心选择必须具备无后效性，也就是某个状态不会影响之前求得的局部最优解。

运动贪心算法解决相应问题时会比较简单和高效，省去了寻找全局最优解很多不必要的穷举操作，由于贪心算法问题并没有固定的贪心策略，所以唯一的难点就是找到带求解问题的贪心策略，但毕竟熟能生巧嘛，算法的基本思想总是固定不变的。

### **贪心算法求解步骤**

1. 将问题分解为若干个子问题
2. 找出适合的贪心策略
3. 求解每一个子问题的最优解
4. 将局部最优解堆叠成全局最优解

下面通过利用贪心算法解决四道LeetCode题目，加深一下对贪心算法思想的掌握，其中第一道为easy，其余三道为medium，会标注出相应的题号。

> 来源：力扣（LeetCode） 链接：[https://leetcode-cn.com](https://link.zhihu.com/?target=https%3A//leetcode-cn.com)

### **455.分发饼干**

问题描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

- 你可以假设胃口值为正。
- 一个小朋友最多只能拥有一块饼干

![img](https://pic2.zhimg.com/v2-c271bce78dc0633f010debd1fd182ebb_r.jpg)

这道题的思路主要包括两个点：

1. 尽量先满足胃口值小的孩子，因为这样的孩子容易满足。
2. 进行条件1时，尽可能选用尺寸小的，这样大尺寸饼干可以用来满足胃口值大的孩子。

这道题的贪心思想非常明显，就是要尽可能地满足更多的孩子，而胃口值小的孩子是容易满足的，反之胃口值大的孩子很难满足，所以在抉择上尽可能满足前者、饿着后者。

这个思想可以类比于赛马，我们假设赢或者平作为满足条件。如果A的3赢了B的1，那么剩下两匹的结果可能就是一平一负或者两负，那么此时至多才是1满足；而如果A的马和B的马都按照顺序比，则可以达到3平，那么此时可以达到3满足。

所以综上可以得到解题思路，首先需要将胃口值和饼干尺寸由小至大排序。设定一个计数器child，用来记得到满足的孩子个数，再维护一个饼干指针cookies。如果饼干尺寸可以满足孩子胃口值，即g[child]<=s[cookies]，就将child、cookies分别加一(向后移动一位)，否则只将cookies向后移动一位。因为孩子的胃口值是由小到大的，若不满足当前的胃口值更不会满足之后的。

![img](https://pic1.zhimg.com/v2-e713cdc1b9ba0269a1fb34f254b3dc2a_r.jpg)

时间复杂度：两次排序加一次循环，如果选择时间复杂度较优的排序方法，那么![[公式]](https://www.zhihu.com/equation?tex=O%28n%29%3DO%28nlogn%29%2BO%28nlogn%29%2BO%28n%29%3DO%28nlogn%29)

### **55. 跳跃游戏**

题目描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

![img](https://pic3.zhimg.com/v2-aabc6ef593a362188662573eef896575_r.jpg)

在解题之前首先明确一下解题目标，若要满足能够到达最后一个位置，那么就需要最后一跳的最大距离加上该位置下标一定要大于等于数组长度，即nums[i]+i>=length(nums)，而当前元素又一定处于之前元素最远可以达到范围之内，这样层层嵌套不就是贪心算法思想中的子问题的形式嘛。

我们要从数组的第一个元素开始遍历，并且维护一个最远可以到达的位置(max_i)，当遍历到数组中的某一个位置i时，如果i在max_i范围之内，并且此时最远可以达到位置大于max_i，那么就通过i+nums[i]更新max_i，如果在遍历过程中max_i大于等于数组长度，则代表可以达到最后一个位置，反之不能。要注意的是，max_i既不是数组下标也不是数组中某个元素，而是二者的加和。

拿上面两个示例为例：

- 示例1：最开始下标为0的元素值为2，此时max_i=2，所以下标1、2都在max_i之内，当达到下标1时，此时max_i = 1+3 = 4，所以可以达到最后一个位置。
- 示例2：最开始下标为0的元素值为3，此时max_i=3，下标1、2、3在范围内，但在遍历这三个位置时会发现max_i=2+1=1+2=0+3总是等于3，而3<4，所以最后一个位置永远达不到。



![img](https://pic3.zhimg.com/v2-3cba17e4f55e1f55f5b570a69d20a304_r.jpg)

时间复杂度：![[公式]](https://www.zhihu.com/equation?tex=O%28n%29)，一层循环。

### **435.无重叠区间**

题目描述：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意：

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。



![img](https://pic4.zhimg.com/v2-daedb21b42018ae5a2f828c13c6948cf_r.jpg)

本题的要求是“找到需要移出区间的最小数量”，换句话说就是要更多地保留集合中的区间，那么对于有重叠的区间，就应该尽可能删去跨度较大的区间。

这里我们根据区间的终点进行贪心选择，不是说起点不行，而是终点更好，那原因呢？因为如果每次选择的区间结尾越小，留给后面区间的空间自然就变多了，那么后面能留下的区间数量也就越多。用一句话概括就是每次都选择终点最小的，因为这一定是最优解的一部分，这不就是正是贪心思想的应用嘛。

解这道题时需要先将数组按照区间的终点进行排序，然后需要维护一个end指针，它代表当前集合中的最小终点，在遍历数组时，若当前元素的起点大于前一区间的终点，那么不重叠区间的计数器加一，更新end指针；反之则不做任何操作，最后区间总数减去不重叠区间即为需要移除区间的最小数量。

![img](https://pic2.zhimg.com/v2-ae7d8ba7cc2f99e4fe724bbd7ca9839c_r.jpg)

时间复杂度：一次排序加一次循环，![[公式]](https://www.zhihu.com/equation?tex=O%28n%29%3DO%28nlogn%29%2BO%28n%29%3DO%28nlogn%29)。

LeetCode中第452题：用最少数量的箭引爆气球与本题解法十分相似，大家可以类比本题的思路自己练习。

### **376. 摆动序列**

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

![img](https://pic1.zhimg.com/v2-f010cfc28bbbc915bdf925a35afc51d9_r.jpg)

示例1和示例3比较特殊，一个是完全摆动序列，另一个是完全升序序列，所以这里利用比较普通的示例2讲解，依据示例2中的数组可以大致绘制出一个元素分布图，如下：

![img](https://picb.zhimg.com/v2-ab3e313354ddba4c03f1f23a42aded9a_r.jpg)

其中橙色点就构成了一个摆动序列，所以橙色点的个数也是最终要输出的结果。可以看到[5,10,13,15]是一个连续递增的子序列，5处于17之后是符合题意的，所以一定将其保留，而对于[10,13,15]三个元素，只有保留15才可以形成摆动序列。

所以对于一段连续递增的子序列，只有保留这段子序列的首尾元素时，才能形成一个摆动序列，并且这也加大了尾部的后一个元素成为摆动序列的下一个元素的可能性。同理连续递减的子序列也做如上操作，比如图中的[15,10,5]。

解决这道题的关键就在于如何保留连续连续递增的子序列首尾元素，结合栈是一个很好的方法，但出栈入栈的条件是什么呢？我们维护一个状态值nowstate，他共有"up"和"down"两种取值，"up"表示该元素大于前一个元素，"dowm"表示该元素小于前一个元素。

从第二个元素开始遍历数组，因为第一个元素(下标为0)一定处于摆动序列内嘛，判断如果当前元素大于前一个元素且nowstate="up"，这就说明连续递增出现了，就需要从栈移除前一个元素。如果不是就更新nowstate为"up"，因为此时前一个nowstate="down"，另一种可能性同理。不论什么条件下都要做入栈操作，因为这里只靠条件过滤不符合的元素。

![img](https://pic4.zhimg.com/v2-fc6f0a85b3bbf1855b44dd62fb106039_r.jpg)

时间复杂度：![[公式]](https://www.zhihu.com/equation?tex=O%28n%29)，一层循环。

### **总结**

从上面几道题中不难看出只要依据题意找出相应的贪心策略，解题就十分容易，并且代码也不复杂，但贪心选择的方法并不唯一，主要还是靠对算法的理解和解题的经验。贪心算法和动态规划是原理有些相似的两种算法，同一问题利用不同算法解题的思路、难易程度各不相同，不要相互混淆。

> 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
>
> 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
>
> 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
>
> I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。
>
> 示例 1:
>
> 输入: 3 输出: "III" 示例 2:
>
> 输入: 4 输出: "IV" 示例 3:
>
> 输入: 9 输出: "IX" 示例 4:
>
> 输入: 58 输出: "LVIII" 解释: L = 50, V = 5, III = 3. 示例 5:
>
> 输入: 1994 输出: "MCMXCIV" 解释: M = 1000, CM = 900, XC = 90, IV = 4.

## [#](https://liweiwei1419.github.io/leetcode-solution-blog/leetcode-problemset/greedy/0012-integer-to-roman.html#贪心算法（python-代码、java-代码）)贪心算法（Python 代码、Java 代码）

![image.png](https://pic.leetcode-cn.com/d8011f9399ca8ffb936c5bcbd09b043dbb22a8f4695d3307cc353773e61fd5c9-image.png)

**特别注意**：本文介绍的是“贪心算法”，但这种贪心选择性质的成立是有一定条件的。跟这里的“候选”数值有关，如果“候选”数值是另一些数字，“贪心算法”很可能就失效了，此时可能就要应用“动态规划”来解决。这一点在本文并不展开，本人也要进行相应的学习以后，才能解释清楚这个问题。也希望能解释清楚这件事情的朋友能够把您的理解分享给大家。

**在生活中的例子**：

> 在以前还使用现金购物的年代，如果我们不想让对方找钱，付款的时候我们会**尽量拿面值大的纸币**给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候（因为对方要检验你给的钱对不对）也最方便。最极端的一种情况，你要是都拿零钱去买一个比较贵重的东西，我相信没有人是很高兴收到你的钱的，因为他们点钱费劲。

“整数转罗马数字”与上面的问题是一模一样的思想：在表示一个较大整数的时候，“罗马数字”不会让你都用 11 加起来，肯定是写出来的“罗马数字”的个数越少越好。

于这道问题，“纸币”有哪些，并不是只有题目中给出的对应关系，根据规则，还可以得到一些“纸币”的面值，不过都是有限个“纸币”，很快就能罗列出来。

于是解这道题的思路就出来了：

- “纸币”有哪些？
- 一个整数如何做“加法因子”的分解？

**思路分析**：

从题目中给出的“罗马数字”与阿拉伯数字的对应关系，和翻译规则，我们需要推导出“罗马数字”还有哪些组合。

| 罗马数字 | 阿拉伯数字 |
| -------- | ---------- |
| `I`      | 11         |
| `V`      | 55         |
| `X`      | 1010       |
| `L`      | 5050       |
| `C`      | 100100     |
| `D`      | 500500     |
| `M`      | 10001000   |

为此，我们要举例子帮助我们发现规律：

| 阿拉伯数字 | 转换规则                                                     | 罗马数字 |
| ---------- | ------------------------------------------------------------ | -------- |
| 11         | 直接看表                                                     | `I`      |
| 22         | 2 = 1 + 12=1+1，相同数字简单叠加                             | `II`     |
| 33         | 3 = 1 + 1 + 13=1+1+1，相同数字简单叠加                       | `III`    |
| 44         | 不能写成 4 = 1 + 1 + 1 + 14=1+1+1+1，44 应该看做 4 = 5 - 14=5−1 | `IV`     |
| 55         | 直接看表                                                     | `V`      |
| 6          | 6 = 5 + 16=5+1，大数字在前，小数字在后                       | `VI`     |
| 7          | 7 = 5 + 1 + 17=5+1+1，大数字在前，小数字在后，相同数字简单叠加 | `VII`    |
| 88         | 8 = 5 + 1 + 1 + 18=5+1+1+1，大数字在前，小数字在后，相同数字简单叠加 | `VIII`   |
| 99         | 不能写成 9 = 5 + 1 + 1 + 1 + 19=5+1+1+1+1，99 应该看做 9 = 10 - 19=10−1 | `IX`     |
| 1010       | 直接看表                                                     | `X`      |

于是，我们发现（其实在题目中已经强调了这些特例），出现 44、99、4040、9090、400400、900900 （40004000、90009000 不讨论了，题目测试用例中有说，不会超过 39993999）的情况比较特殊一些，做的是减法，**把它们也加入到“罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列**。

| 罗马数字 | 阿拉伯数字 |
| -------- | ---------- |
| `M`      | 10001000   |
| `CM`     | 900900     |
| `D`      | 500500     |
| `CD`     | 400400     |
| `C`      | 100100     |
| `XC`     | 9090       |
| `L`      | 5050       |
| `XL`     | 4040       |
| `X`      | 1010       |
| `IX`     | 99         |
| `V`      | 55         |
| `IV`     | 44         |
| `I`      | 11         |

于是，“将整数转换为阿拉伯数字”的过程，就是我们用上面这张表中右边的数字作为“加法因子”去分解一个整数，并且分解的整数个数越少越好，即**尽量使用靠前的数字**，这可以认为是一种贪心法则。

**参考代码**：

Python 代码：

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        romans = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]

        index = 0
        res = ''
        while index < 13:
            # 注意：这里是等于号，表示尽量使用大的"面值"
            while num >= nums[index]:
                res += romans[index]
                num -= nums[index]
            index += 1
        return res
```

#### 直接用复制字符串操作直接起飞

```python
class Solution(object):

    def __init__(self):
        self._rules = (
            ('M', 1000),
            ('CM', 900), ('D', 500), ('CD', 400), ('C', 100),
            ('XC', 90), ('L', 50), ('XL', 40), ('X', 10),
            ('IX', 9), ('V', 5), ('IV', 4), ('I', 1),
        )

    def intToRoman(self, num: int) -> str:
        result = []

        for roman, dec in self._rules:
            if num >= dec:
                result.extend([roman] * (num // dec))#注意要复制的次数就是求模个数
                num %= dec#剩下求余

        return ''.join(result)
```

Java 代码：

```java
public class Solution {

    public String intToRoman(int num) {
        // 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
        // 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
        int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] romans = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        StringBuilder stringBuilder = new StringBuilder();
        int index = 0;
        while (index < 13) {
            // 特别注意：这里是等号
            while (num >= nums[index]) {
                // 注意：这里是等于号，表示尽量使用大的"面值"
                stringBuilder.append(romans[index] + " ");
                num -= nums[index];
            }
            index++;
        }
        return stringBuilder.toString();
    }
}
```

**复杂度分析**：

- 时间复杂度：O(1)*O*(1)，虽然看起来是两层循环，但是外层循环的次数最多 1212，内层循环的此时其实也是有限次的，综合一下，时间复杂度是 O(1)*O*(1)。
- 空间复杂度：O(1)*O*(1)，这里使用了两个辅助数字，空间都为 1313，还有常数个变量，故空间复杂度是 O(1)*O*(1)。
- ![截图_2020090422571557SS](H:\下载\截图_2020090422571557SS.gif)

#### 哈希表

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        # 使用哈希表，按照从大到小顺序排列
        hashmap = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'}
        res = ''
        for key in hashmap:
            if num // key != 0:
                count = num // key  # 比如输入4000，count 为 4
                res += hashmap[key] * count 
                num %= key
        return res


```

![image-20200904221323935](C:\Users\kumi\AppData\Roaming\Typora\typora-user-images\image-20200904221323935.png)

```python
#类似于直接插表格
class Solution:
    def intToRoman(self, num: int) -> str:
        M = ["", "M", "MM", "MMM"] # 1000，2000，3000
        C = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"] # 100~900
        X = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"] # 10~90
        I = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"] # 1~9
        return M[num//1000] + C[(num%1000)//100] + X[(num%100)//10] + I[num%10]


```



### 合并区间

https://leetcode-cn.com/problems/merge-intervals/solution/tan-xin-suan-fa-java-by-liweiwei1419-3/

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if len(intervals)<=1:
            return intervals
        intervals=sorted(intervals,key=lambda x:x[0])
        res=[intervals[0]]
        for element in intervals[1:]:
            if element[0]<=res[-1][1]:
                res[-1][1]=max(element[1],res[-1][1])
            else:
                res.append(element)
        return res

```

#### 或者栈模拟

```python
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);
        Stack<int[]> stack = new Stack<>();
        
        for(int[] a: intervals){
            
            if(stack.isEmpty()) stack.push(a);
            else{
                
                int[] arr = stack.pop();
                if(arr[1] >= a[0]) {
                    int[] combine = { arr[0] , Math.max( arr[1] , a[1] ) };
                    stack.push(combine);
                }else{
                    stack.push(arr);
                    stack.push(a);
                }
                    
            }
            
        }
        
        return stack.toArray(new int[0][]);
    }
}
```

